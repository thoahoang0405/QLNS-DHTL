{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst getGeneratedSourceInfo = require(\"./getGeneratedSourceInfo\");\nconst getSource = require(\"./getSource\");\nconst readMappings = require(\"./readMappings\");\nconst splitIntoLines = require(\"./splitIntoLines\");\nconst streamChunksOfSourceMapFull = (source, sourceMap, onChunk, onSource, onName) => {\n  const lines = splitIntoLines(source);\n  if (lines.length === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n  const {\n    sources,\n    sourcesContent,\n    names,\n    mappings\n  } = sourceMap;\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n  if (names) {\n    for (let i = 0; i < names.length; i++) {\n      onName(i, names[i]);\n    }\n  }\n  const lastLine = lines[lines.length - 1];\n  const lastNewLine = lastLine.endsWith(\"\\n\");\n  const finalLine = lastNewLine ? lines.length + 1 : lines.length;\n  const finalColumn = lastNewLine ? 0 : lastLine.length;\n  let currentGeneratedLine = 1;\n  let currentGeneratedColumn = 0;\n  let mappingActive = false;\n  let activeMappingSourceIndex = -1;\n  let activeMappingOriginalLine = -1;\n  let activeMappingOriginalColumn = -1;\n  let activeMappingNameIndex = -1;\n  const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n    if (mappingActive && currentGeneratedLine <= lines.length) {\n      let chunk;\n      const mappingLine = currentGeneratedLine;\n      const mappingColumn = currentGeneratedColumn;\n      const line = lines[currentGeneratedLine - 1];\n      if (generatedLine !== currentGeneratedLine) {\n        chunk = line.slice(currentGeneratedColumn);\n        currentGeneratedLine++;\n        currentGeneratedColumn = 0;\n      } else {\n        chunk = line.slice(currentGeneratedColumn, generatedColumn);\n        currentGeneratedColumn = generatedColumn;\n      }\n      if (chunk) {\n        onChunk(chunk, mappingLine, mappingColumn, activeMappingSourceIndex, activeMappingOriginalLine, activeMappingOriginalColumn, activeMappingNameIndex);\n      }\n      mappingActive = false;\n    }\n    if (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {\n      if (currentGeneratedLine <= lines.length) {\n        const chunk = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn);\n        onChunk(chunk, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);\n      }\n      currentGeneratedLine++;\n      currentGeneratedColumn = 0;\n    }\n    while (generatedLine > currentGeneratedLine) {\n      if (currentGeneratedLine <= lines.length) {\n        onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n      }\n      currentGeneratedLine++;\n    }\n    if (generatedColumn > currentGeneratedColumn) {\n      if (currentGeneratedLine <= lines.length) {\n        const chunk = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn, generatedColumn);\n        onChunk(chunk, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);\n      }\n      currentGeneratedColumn = generatedColumn;\n    }\n    if (sourceIndex >= 0 && (generatedLine < finalLine || generatedLine === finalLine && generatedColumn < finalColumn)) {\n      mappingActive = true;\n      activeMappingSourceIndex = sourceIndex;\n      activeMappingOriginalLine = originalLine;\n      activeMappingOriginalColumn = originalColumn;\n      activeMappingNameIndex = nameIndex;\n    }\n  };\n  readMappings(mappings, onMapping);\n  onMapping(finalLine, finalColumn, -1, -1, -1, -1);\n  return {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  };\n};\nconst streamChunksOfSourceMapLinesFull = (source, sourceMap, onChunk, onSource, _onName) => {\n  const lines = splitIntoLines(source);\n  if (lines.length === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n  const {\n    sources,\n    sourcesContent,\n    mappings\n  } = sourceMap;\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n  let currentGeneratedLine = 1;\n  const onMapping = (generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {\n    if (sourceIndex < 0 || generatedLine < currentGeneratedLine || generatedLine > lines.length) {\n      return;\n    }\n    while (generatedLine > currentGeneratedLine) {\n      if (currentGeneratedLine <= lines.length) {\n        onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n      }\n      currentGeneratedLine++;\n    }\n    if (generatedLine <= lines.length) {\n      onChunk(lines[generatedLine - 1], generatedLine, 0, sourceIndex, originalLine, originalColumn, -1);\n      currentGeneratedLine++;\n    }\n  };\n  readMappings(mappings, onMapping);\n  for (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {\n    onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n  }\n  const lastLine = lines[lines.length - 1];\n  const lastNewLine = lastLine.endsWith(\"\\n\");\n  const finalLine = lastNewLine ? lines.length + 1 : lines.length;\n  const finalColumn = lastNewLine ? 0 : lastLine.length;\n  return {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  };\n};\nconst streamChunksOfSourceMapFinal = (source, sourceMap, onChunk, onSource, onName) => {\n  const result = getGeneratedSourceInfo(source);\n  const {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  } = result;\n  if (finalLine === 1 && finalColumn === 0) return result;\n  const {\n    sources,\n    sourcesContent,\n    names,\n    mappings\n  } = sourceMap;\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n  if (names) {\n    for (let i = 0; i < names.length; i++) {\n      onName(i, names[i]);\n    }\n  }\n  let mappingActiveLine = 0;\n  const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n    if (generatedLine >= finalLine && (generatedColumn >= finalColumn || generatedLine > finalLine)) {\n      return;\n    }\n    if (sourceIndex >= 0) {\n      onChunk(undefined, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n      mappingActiveLine = generatedLine;\n    } else if (mappingActiveLine === generatedLine) {\n      onChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);\n      mappingActiveLine = 0;\n    }\n  };\n  readMappings(mappings, onMapping);\n  return result;\n};\nconst streamChunksOfSourceMapLinesFinal = (source, sourceMap, onChunk, onSource, _onName) => {\n  const result = getGeneratedSourceInfo(source);\n  const {\n    generatedLine,\n    generatedColumn\n  } = result;\n  if (generatedLine === 1 && generatedColumn === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n  const {\n    sources,\n    sourcesContent,\n    mappings\n  } = sourceMap;\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n  const finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;\n  let currentGeneratedLine = 1;\n  const onMapping = (generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {\n    if (sourceIndex >= 0 && currentGeneratedLine <= generatedLine && generatedLine <= finalLine) {\n      onChunk(undefined, generatedLine, 0, sourceIndex, originalLine, originalColumn, -1);\n      currentGeneratedLine = generatedLine + 1;\n    }\n  };\n  readMappings(mappings, onMapping);\n  return result;\n};\nmodule.exports = (source, sourceMap, onChunk, onSource, onName, finalSource, columns) => {\n  if (columns) {\n    return finalSource ? streamChunksOfSourceMapFinal(source, sourceMap, onChunk, onSource, onName) : streamChunksOfSourceMapFull(source, sourceMap, onChunk, onSource, onName);\n  } else {\n    return finalSource ? streamChunksOfSourceMapLinesFinal(source, sourceMap, onChunk, onSource, onName) : streamChunksOfSourceMapLinesFull(source, sourceMap, onChunk, onSource, onName);\n  }\n};","map":{"version":3,"names":["getGeneratedSourceInfo","require","getSource","readMappings","splitIntoLines","streamChunksOfSourceMapFull","source","sourceMap","onChunk","onSource","onName","lines","length","generatedLine","generatedColumn","sources","sourcesContent","names","mappings","i","undefined","lastLine","lastNewLine","endsWith","finalLine","finalColumn","currentGeneratedLine","currentGeneratedColumn","mappingActive","activeMappingSourceIndex","activeMappingOriginalLine","activeMappingOriginalColumn","activeMappingNameIndex","onMapping","sourceIndex","originalLine","originalColumn","nameIndex","chunk","mappingLine","mappingColumn","line","slice","streamChunksOfSourceMapLinesFull","_onName","_generatedColumn","_nameIndex","streamChunksOfSourceMapFinal","result","mappingActiveLine","streamChunksOfSourceMapLinesFinal","module","exports","finalSource","columns"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst getGeneratedSourceInfo = require(\"./getGeneratedSourceInfo\");\r\nconst getSource = require(\"./getSource\");\r\nconst readMappings = require(\"./readMappings\");\r\nconst splitIntoLines = require(\"./splitIntoLines\");\r\n\r\nconst streamChunksOfSourceMapFull = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\tonName\r\n) => {\r\n\tconst lines = splitIntoLines(source);\r\n\tif (lines.length === 0) {\r\n\t\treturn {\r\n\t\t\tgeneratedLine: 1,\r\n\t\t\tgeneratedColumn: 0\r\n\t\t};\r\n\t}\r\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\r\n\tfor (let i = 0; i < sources.length; i++) {\r\n\t\tonSource(\r\n\t\t\ti,\r\n\t\t\tgetSource(sourceMap, i),\r\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\r\n\t\t);\r\n\t}\r\n\tif (names) {\r\n\t\tfor (let i = 0; i < names.length; i++) {\r\n\t\t\tonName(i, names[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tconst lastLine = lines[lines.length - 1];\r\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\r\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\r\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\r\n\r\n\tlet currentGeneratedLine = 1;\r\n\tlet currentGeneratedColumn = 0;\r\n\r\n\tlet mappingActive = false;\r\n\tlet activeMappingSourceIndex = -1;\r\n\tlet activeMappingOriginalLine = -1;\r\n\tlet activeMappingOriginalColumn = -1;\r\n\tlet activeMappingNameIndex = -1;\r\n\r\n\tconst onMapping = (\r\n\t\tgeneratedLine,\r\n\t\tgeneratedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\toriginalColumn,\r\n\t\tnameIndex\r\n\t) => {\r\n\t\tif (mappingActive && currentGeneratedLine <= lines.length) {\r\n\t\t\tlet chunk;\r\n\t\t\tconst mappingLine = currentGeneratedLine;\r\n\t\t\tconst mappingColumn = currentGeneratedColumn;\r\n\t\t\tconst line = lines[currentGeneratedLine - 1];\r\n\t\t\tif (generatedLine !== currentGeneratedLine) {\r\n\t\t\t\tchunk = line.slice(currentGeneratedColumn);\r\n\t\t\t\tcurrentGeneratedLine++;\r\n\t\t\t\tcurrentGeneratedColumn = 0;\r\n\t\t\t} else {\r\n\t\t\t\tchunk = line.slice(currentGeneratedColumn, generatedColumn);\r\n\t\t\t\tcurrentGeneratedColumn = generatedColumn;\r\n\t\t\t}\r\n\t\t\tif (chunk) {\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tmappingLine,\r\n\t\t\t\t\tmappingColumn,\r\n\t\t\t\t\tactiveMappingSourceIndex,\r\n\t\t\t\t\tactiveMappingOriginalLine,\r\n\t\t\t\t\tactiveMappingOriginalColumn,\r\n\t\t\t\t\tactiveMappingNameIndex\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tmappingActive = false;\r\n\t\t}\r\n\t\tif (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {\r\n\t\t\tif (currentGeneratedLine <= lines.length) {\r\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\r\n\t\t\t\t\tcurrentGeneratedColumn\r\n\t\t\t\t);\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tcurrentGeneratedLine,\r\n\t\t\t\t\tcurrentGeneratedColumn,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentGeneratedLine++;\r\n\t\t\tcurrentGeneratedColumn = 0;\r\n\t\t}\r\n\t\twhile (generatedLine > currentGeneratedLine) {\r\n\t\t\tif (currentGeneratedLine <= lines.length) {\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tlines[currentGeneratedLine - 1],\r\n\t\t\t\t\tcurrentGeneratedLine,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentGeneratedLine++;\r\n\t\t}\r\n\t\tif (generatedColumn > currentGeneratedColumn) {\r\n\t\t\tif (currentGeneratedLine <= lines.length) {\r\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\r\n\t\t\t\t\tcurrentGeneratedColumn,\r\n\t\t\t\t\tgeneratedColumn\r\n\t\t\t\t);\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tcurrentGeneratedLine,\r\n\t\t\t\t\tcurrentGeneratedColumn,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentGeneratedColumn = generatedColumn;\r\n\t\t}\r\n\t\tif (\r\n\t\t\tsourceIndex >= 0 &&\r\n\t\t\t(generatedLine < finalLine ||\r\n\t\t\t\t(generatedLine === finalLine && generatedColumn < finalColumn))\r\n\t\t) {\r\n\t\t\tmappingActive = true;\r\n\t\t\tactiveMappingSourceIndex = sourceIndex;\r\n\t\t\tactiveMappingOriginalLine = originalLine;\r\n\t\t\tactiveMappingOriginalColumn = originalColumn;\r\n\t\t\tactiveMappingNameIndex = nameIndex;\r\n\t\t}\r\n\t};\r\n\treadMappings(mappings, onMapping);\r\n\tonMapping(finalLine, finalColumn, -1, -1, -1, -1);\r\n\treturn {\r\n\t\tgeneratedLine: finalLine,\r\n\t\tgeneratedColumn: finalColumn\r\n\t};\r\n};\r\n\r\nconst streamChunksOfSourceMapLinesFull = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\t_onName\r\n) => {\r\n\tconst lines = splitIntoLines(source);\r\n\tif (lines.length === 0) {\r\n\t\treturn {\r\n\t\t\tgeneratedLine: 1,\r\n\t\t\tgeneratedColumn: 0\r\n\t\t};\r\n\t}\r\n\tconst { sources, sourcesContent, mappings } = sourceMap;\r\n\tfor (let i = 0; i < sources.length; i++) {\r\n\t\tonSource(\r\n\t\t\ti,\r\n\t\t\tgetSource(sourceMap, i),\r\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\r\n\t\t);\r\n\t}\r\n\r\n\tlet currentGeneratedLine = 1;\r\n\r\n\tconst onMapping = (\r\n\t\tgeneratedLine,\r\n\t\t_generatedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\toriginalColumn,\r\n\t\t_nameIndex\r\n\t) => {\r\n\t\tif (\r\n\t\t\tsourceIndex < 0 ||\r\n\t\t\tgeneratedLine < currentGeneratedLine ||\r\n\t\t\tgeneratedLine > lines.length\r\n\t\t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twhile (generatedLine > currentGeneratedLine) {\r\n\t\t\tif (currentGeneratedLine <= lines.length) {\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tlines[currentGeneratedLine - 1],\r\n\t\t\t\t\tcurrentGeneratedLine,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1,\r\n\t\t\t\t\t-1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentGeneratedLine++;\r\n\t\t}\r\n\t\tif (generatedLine <= lines.length) {\r\n\t\t\tonChunk(\r\n\t\t\t\tlines[generatedLine - 1],\r\n\t\t\t\tgeneratedLine,\r\n\t\t\t\t0,\r\n\t\t\t\tsourceIndex,\r\n\t\t\t\toriginalLine,\r\n\t\t\t\toriginalColumn,\r\n\t\t\t\t-1\r\n\t\t\t);\r\n\t\t\tcurrentGeneratedLine++;\r\n\t\t}\r\n\t};\r\n\treadMappings(mappings, onMapping);\r\n\tfor (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {\r\n\t\tonChunk(\r\n\t\t\tlines[currentGeneratedLine - 1],\r\n\t\t\tcurrentGeneratedLine,\r\n\t\t\t0,\r\n\t\t\t-1,\r\n\t\t\t-1,\r\n\t\t\t-1,\r\n\t\t\t-1\r\n\t\t);\r\n\t}\r\n\r\n\tconst lastLine = lines[lines.length - 1];\r\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\r\n\r\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\r\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\r\n\r\n\treturn {\r\n\t\tgeneratedLine: finalLine,\r\n\t\tgeneratedColumn: finalColumn\r\n\t};\r\n};\r\n\r\nconst streamChunksOfSourceMapFinal = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\tonName\r\n) => {\r\n\tconst result = getGeneratedSourceInfo(source);\r\n\tconst { generatedLine: finalLine, generatedColumn: finalColumn } = result;\r\n\r\n\tif (finalLine === 1 && finalColumn === 0) return result;\r\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\r\n\tfor (let i = 0; i < sources.length; i++) {\r\n\t\tonSource(\r\n\t\t\ti,\r\n\t\t\tgetSource(sourceMap, i),\r\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\r\n\t\t);\r\n\t}\r\n\tif (names) {\r\n\t\tfor (let i = 0; i < names.length; i++) {\r\n\t\t\tonName(i, names[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tlet mappingActiveLine = 0;\r\n\r\n\tconst onMapping = (\r\n\t\tgeneratedLine,\r\n\t\tgeneratedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\toriginalColumn,\r\n\t\tnameIndex\r\n\t) => {\r\n\t\tif (\r\n\t\t\tgeneratedLine >= finalLine &&\r\n\t\t\t(generatedColumn >= finalColumn || generatedLine > finalLine)\r\n\t\t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (sourceIndex >= 0) {\r\n\t\t\tonChunk(\r\n\t\t\t\tundefined,\r\n\t\t\t\tgeneratedLine,\r\n\t\t\t\tgeneratedColumn,\r\n\t\t\t\tsourceIndex,\r\n\t\t\t\toriginalLine,\r\n\t\t\t\toriginalColumn,\r\n\t\t\t\tnameIndex\r\n\t\t\t);\r\n\t\t\tmappingActiveLine = generatedLine;\r\n\t\t} else if (mappingActiveLine === generatedLine) {\r\n\t\t\tonChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);\r\n\t\t\tmappingActiveLine = 0;\r\n\t\t}\r\n\t};\r\n\treadMappings(mappings, onMapping);\r\n\treturn result;\r\n};\r\n\r\nconst streamChunksOfSourceMapLinesFinal = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\t_onName\r\n) => {\r\n\tconst result = getGeneratedSourceInfo(source);\r\n\tconst { generatedLine, generatedColumn } = result;\r\n\tif (generatedLine === 1 && generatedColumn === 0) {\r\n\t\treturn {\r\n\t\t\tgeneratedLine: 1,\r\n\t\t\tgeneratedColumn: 0\r\n\t\t};\r\n\t}\r\n\r\n\tconst { sources, sourcesContent, mappings } = sourceMap;\r\n\tfor (let i = 0; i < sources.length; i++) {\r\n\t\tonSource(\r\n\t\t\ti,\r\n\t\t\tgetSource(sourceMap, i),\r\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\r\n\t\t);\r\n\t}\r\n\r\n\tconst finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;\r\n\r\n\tlet currentGeneratedLine = 1;\r\n\r\n\tconst onMapping = (\r\n\t\tgeneratedLine,\r\n\t\t_generatedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\toriginalColumn,\r\n\t\t_nameIndex\r\n\t) => {\r\n\t\tif (\r\n\t\t\tsourceIndex >= 0 &&\r\n\t\t\tcurrentGeneratedLine <= generatedLine &&\r\n\t\t\tgeneratedLine <= finalLine\r\n\t\t) {\r\n\t\t\tonChunk(\r\n\t\t\t\tundefined,\r\n\t\t\t\tgeneratedLine,\r\n\t\t\t\t0,\r\n\t\t\t\tsourceIndex,\r\n\t\t\t\toriginalLine,\r\n\t\t\t\toriginalColumn,\r\n\t\t\t\t-1\r\n\t\t\t);\r\n\t\t\tcurrentGeneratedLine = generatedLine + 1;\r\n\t\t}\r\n\t};\r\n\treadMappings(mappings, onMapping);\r\n\treturn result;\r\n};\r\n\r\nmodule.exports = (\r\n\tsource,\r\n\tsourceMap,\r\n\tonChunk,\r\n\tonSource,\r\n\tonName,\r\n\tfinalSource,\r\n\tcolumns\r\n) => {\r\n\tif (columns) {\r\n\t\treturn finalSource\r\n\t\t\t? streamChunksOfSourceMapFinal(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tsourceMap,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName\r\n\t\t\t  )\r\n\t\t\t: streamChunksOfSourceMapFull(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tsourceMap,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName\r\n\t\t\t  );\r\n\t} else {\r\n\t\treturn finalSource\r\n\t\t\t? streamChunksOfSourceMapLinesFinal(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tsourceMap,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName\r\n\t\t\t  )\r\n\t\t\t: streamChunksOfSourceMapLinesFull(\r\n\t\t\t\t\tsource,\r\n\t\t\t\t\tsourceMap,\r\n\t\t\t\t\tonChunk,\r\n\t\t\t\t\tonSource,\r\n\t\t\t\t\tonName\r\n\t\t\t  );\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}