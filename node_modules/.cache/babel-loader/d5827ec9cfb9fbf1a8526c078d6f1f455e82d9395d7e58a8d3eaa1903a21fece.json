{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nfunction _sliceIterator(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _slicedToArray(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    return _sliceIterator(arr, i);\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\nimport { encodeNode } from \"@webassemblyjs/wasm-gen\";\nimport { encodeU32 } from \"@webassemblyjs/wasm-gen/lib/encoder\";\nimport { isFunc, isGlobal, assertHasLoc, orderedInsertNode, getSectionMetadata, traverse, getEndOfSection } from \"@webassemblyjs/ast\";\nimport { resizeSectionByteSize, resizeSectionVecSize, createEmptySection, removeSections } from \"@webassemblyjs/helper-wasm-section\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\nimport { getSectionForNode } from \"@webassemblyjs/helper-wasm-bytecode\";\nfunction shiftLocNodeByDelta(node, delta) {\n  assertHasLoc(node); // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.start.column += delta; // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.end.column += delta;\n}\nfunction applyUpdate(ast, uint8Buffer, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    oldNode = _ref2[0],\n    newNode = _ref2[1];\n  var deltaElements = 0;\n  assertHasLoc(oldNode);\n  var sectionName = getSectionForNode(newNode);\n  var replacementByteArray = encodeNode(newNode);\n  /**\r\n   * Replace new node as bytes\r\n   */\n\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer,\n  // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column,\n  // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column, replacementByteArray);\n  /**\r\n   * Update function body size if needed\r\n   */\n\n  if (sectionName === \"code\") {\n    // Find the parent func\n    traverse(ast, {\n      Func: function Func(_ref3) {\n        var node = _ref3.node;\n        var funcHasThisIntr = node.body.find(function (n) {\n          return n === newNode;\n        }) !== undefined; // Update func's body size if needed\n\n        if (funcHasThisIntr === true) {\n          // These are the old functions locations informations\n          assertHasLoc(node);\n          var oldNodeSize = encodeNode(oldNode).length;\n          var bodySizeDeltaBytes = replacementByteArray.length - oldNodeSize;\n          if (bodySizeDeltaBytes !== 0) {\n            var newValue = node.metadata.bodySize + bodySizeDeltaBytes;\n            var newByteArray = encodeU32(newValue); // function body size byte\n            // FIXME(sven): only handles one byte u32\n\n            var start = node.loc.start.column;\n            var end = start + 1;\n            uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newByteArray);\n          }\n        }\n      }\n    });\n  }\n  /**\r\n   * Update section size\r\n   */\n\n  var deltaBytes = replacementByteArray.length - (\n  // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column - oldNode.loc.start.column); // Init location informations\n\n  newNode.loc = {\n    start: {\n      line: -1,\n      column: -1\n    },\n    end: {\n      line: -1,\n      column: -1\n    }\n  }; // Update new node end position\n  // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.start.column = oldNode.loc.start.column; // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.end.column =\n  // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column + replacementByteArray.length;\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\nfunction applyDelete(ast, uint8Buffer, node) {\n  var deltaElements = -1; // since we removed an element\n\n  assertHasLoc(node);\n  var sectionName = getSectionForNode(node);\n  if (sectionName === \"start\") {\n    var sectionMetadata = getSectionMetadata(ast, \"start\");\n    /**\r\n     * The start section only contains one element,\r\n     * we need to remove the whole section\r\n     */\n\n    uint8Buffer = removeSections(ast, uint8Buffer, \"start\");\n    var _deltaBytes = -(sectionMetadata.size.value + 1);\n    /* section id */\n\n    return {\n      uint8Buffer: uint8Buffer,\n      deltaBytes: _deltaBytes,\n      deltaElements: deltaElements\n    };\n  } // replacement is nothing\n\n  var replacement = [];\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer,\n  // $FlowIgnore: assertHasLoc ensures that\n  node.loc.start.column,\n  // $FlowIgnore: assertHasLoc ensures that\n  node.loc.end.column, replacement);\n  /**\r\n   * Update section\r\n   */\n  // $FlowIgnore: assertHasLoc ensures that\n\n  var deltaBytes = -(node.loc.end.column - node.loc.start.column);\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\nfunction applyAdd(ast, uint8Buffer, node) {\n  var deltaElements = +1; // since we added an element\n\n  var sectionName = getSectionForNode(node);\n  var sectionMetadata = getSectionMetadata(ast, sectionName); // Section doesn't exists, we create an empty one\n\n  if (typeof sectionMetadata === \"undefined\") {\n    var res = createEmptySection(ast, uint8Buffer, sectionName);\n    uint8Buffer = res.uint8Buffer;\n    sectionMetadata = res.sectionMetadata;\n  }\n  /**\r\n   * check that the expressions were ended\r\n   */\n\n  if (isFunc(node)) {\n    // $FlowIgnore\n    var body = node.body;\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  if (isGlobal(node)) {\n    // $FlowIgnore\n    var body = node.init;\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  /**\r\n   * Add nodes\r\n   */\n\n  var newByteArray = encodeNode(node); // The size of the section doesn't include the storage of the size itself\n  // we need to manually add it here\n\n  var start = getEndOfSection(sectionMetadata);\n  var end = start;\n  /**\r\n   * Update section\r\n   */\n\n  var deltaBytes = newByteArray.length;\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newByteArray);\n  node.loc = {\n    start: {\n      line: -1,\n      column: start\n    },\n    end: {\n      line: -1,\n      column: start + deltaBytes\n    }\n  }; // for func add the additional metadata in the AST\n\n  if (node.type === \"Func\") {\n    // the size is the first byte\n    // FIXME(sven): handle LEB128 correctly here\n    var bodySize = newByteArray[0];\n    node.metadata = {\n      bodySize: bodySize\n    };\n  }\n  if (node.type !== \"IndexInFuncSection\") {\n    orderedInsertNode(ast.body[0], node);\n  }\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\nexport function applyOperations(ast, uint8Buffer, ops) {\n  ops.forEach(function (op) {\n    var state;\n    var sectionName;\n    switch (op.kind) {\n      case \"update\":\n        state = applyUpdate(ast, uint8Buffer, [op.oldNode, op.node]);\n        sectionName = getSectionForNode(op.node);\n        break;\n      case \"delete\":\n        state = applyDelete(ast, uint8Buffer, op.node);\n        sectionName = getSectionForNode(op.node);\n        break;\n      case \"add\":\n        state = applyAdd(ast, uint8Buffer, op.node);\n        sectionName = getSectionForNode(op.node);\n        break;\n      default:\n        throw new Error(\"Unknown operation\");\n    }\n    /**\r\n     * Resize section vec size.\r\n     * If the length of the LEB-encoded size changes, this can change\r\n     * the byte length of the section and the offset for nodes in the\r\n     * section. So we do this first before resizing section byte size\r\n     * or shifting following operations' nodes.\r\n     */\n\n    if (state.deltaElements !== 0 && sectionName !== \"start\") {\n      var oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = resizeSectionVecSize(ast, state.uint8Buffer, sectionName, state.deltaElements); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - oldBufferLength;\n    }\n    /**\r\n     * Resize section byte size.\r\n     * If the length of the LEB-encoded size changes, this can change\r\n     * the offset for nodes in the section. So we do this before\r\n     * shifting following operations' nodes.\r\n     */\n\n    if (state.deltaBytes !== 0 && sectionName !== \"start\") {\n      var _oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = resizeSectionByteSize(ast, state.uint8Buffer, sectionName, state.deltaBytes); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - _oldBufferLength;\n    }\n    /**\r\n     * Shift following operation's nodes\r\n     */\n\n    if (state.deltaBytes !== 0) {\n      ops.forEach(function (op) {\n        // We don't need to handle add ops, they are positioning independent\n        switch (op.kind) {\n          case \"update\":\n            shiftLocNodeByDelta(op.oldNode, state.deltaBytes);\n            break;\n          case \"delete\":\n            shiftLocNodeByDelta(op.node, state.deltaBytes);\n            break;\n        }\n      });\n    }\n    uint8Buffer = state.uint8Buffer;\n  });\n  return uint8Buffer;\n}","map":{"version":3,"names":["_sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","_slicedToArray","Array","isArray","Object","TypeError","encodeNode","encodeU32","isFunc","isGlobal","assertHasLoc","orderedInsertNode","getSectionMetadata","traverse","getEndOfSection","resizeSectionByteSize","resizeSectionVecSize","createEmptySection","removeSections","overrideBytesInBuffer","getSectionForNode","shiftLocNodeByDelta","node","delta","loc","start","column","end","applyUpdate","ast","uint8Buffer","_ref","_ref2","oldNode","newNode","deltaElements","sectionName","replacementByteArray","Func","_ref3","funcHasThisIntr","body","find","n","oldNodeSize","bodySizeDeltaBytes","newValue","metadata","bodySize","newByteArray","deltaBytes","line","applyDelete","sectionMetadata","_deltaBytes","size","replacement","applyAdd","res","id","Error","init","type","applyOperations","ops","forEach","op","state","kind","oldBufferLength","_oldBufferLength"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/@webassemblyjs/wasm-edit/esm/apply.js"],"sourcesContent":["function _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }\r\n\r\nimport { encodeNode } from \"@webassemblyjs/wasm-gen\";\r\nimport { encodeU32 } from \"@webassemblyjs/wasm-gen/lib/encoder\";\r\nimport { isFunc, isGlobal, assertHasLoc, orderedInsertNode, getSectionMetadata, traverse, getEndOfSection } from \"@webassemblyjs/ast\";\r\nimport { resizeSectionByteSize, resizeSectionVecSize, createEmptySection, removeSections } from \"@webassemblyjs/helper-wasm-section\";\r\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\r\nimport { getSectionForNode } from \"@webassemblyjs/helper-wasm-bytecode\";\r\n\r\nfunction shiftLocNodeByDelta(node, delta) {\r\n  assertHasLoc(node); // $FlowIgnore: assertHasLoc ensures that\r\n\r\n  node.loc.start.column += delta; // $FlowIgnore: assertHasLoc ensures that\r\n\r\n  node.loc.end.column += delta;\r\n}\r\n\r\nfunction applyUpdate(ast, uint8Buffer, _ref) {\r\n  var _ref2 = _slicedToArray(_ref, 2),\r\n      oldNode = _ref2[0],\r\n      newNode = _ref2[1];\r\n\r\n  var deltaElements = 0;\r\n  assertHasLoc(oldNode);\r\n  var sectionName = getSectionForNode(newNode);\r\n  var replacementByteArray = encodeNode(newNode);\r\n  /**\r\n   * Replace new node as bytes\r\n   */\r\n\r\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\r\n  oldNode.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\r\n  oldNode.loc.end.column, replacementByteArray);\r\n  /**\r\n   * Update function body size if needed\r\n   */\r\n\r\n  if (sectionName === \"code\") {\r\n    // Find the parent func\r\n    traverse(ast, {\r\n      Func: function Func(_ref3) {\r\n        var node = _ref3.node;\r\n        var funcHasThisIntr = node.body.find(function (n) {\r\n          return n === newNode;\r\n        }) !== undefined; // Update func's body size if needed\r\n\r\n        if (funcHasThisIntr === true) {\r\n          // These are the old functions locations informations\r\n          assertHasLoc(node);\r\n          var oldNodeSize = encodeNode(oldNode).length;\r\n          var bodySizeDeltaBytes = replacementByteArray.length - oldNodeSize;\r\n\r\n          if (bodySizeDeltaBytes !== 0) {\r\n            var newValue = node.metadata.bodySize + bodySizeDeltaBytes;\r\n            var newByteArray = encodeU32(newValue); // function body size byte\r\n            // FIXME(sven): only handles one byte u32\r\n\r\n            var start = node.loc.start.column;\r\n            var end = start + 1;\r\n            uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newByteArray);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Update section size\r\n   */\r\n\r\n\r\n  var deltaBytes = replacementByteArray.length - ( // $FlowIgnore: assertHasLoc ensures that\r\n  oldNode.loc.end.column - oldNode.loc.start.column); // Init location informations\r\n\r\n  newNode.loc = {\r\n    start: {\r\n      line: -1,\r\n      column: -1\r\n    },\r\n    end: {\r\n      line: -1,\r\n      column: -1\r\n    }\r\n  }; // Update new node end position\r\n  // $FlowIgnore: assertHasLoc ensures that\r\n\r\n  newNode.loc.start.column = oldNode.loc.start.column; // $FlowIgnore: assertHasLoc ensures that\r\n\r\n  newNode.loc.end.column = // $FlowIgnore: assertHasLoc ensures that\r\n  oldNode.loc.start.column + replacementByteArray.length;\r\n  return {\r\n    uint8Buffer: uint8Buffer,\r\n    deltaBytes: deltaBytes,\r\n    deltaElements: deltaElements\r\n  };\r\n}\r\n\r\nfunction applyDelete(ast, uint8Buffer, node) {\r\n  var deltaElements = -1; // since we removed an element\r\n\r\n  assertHasLoc(node);\r\n  var sectionName = getSectionForNode(node);\r\n\r\n  if (sectionName === \"start\") {\r\n    var sectionMetadata = getSectionMetadata(ast, \"start\");\r\n    /**\r\n     * The start section only contains one element,\r\n     * we need to remove the whole section\r\n     */\r\n\r\n    uint8Buffer = removeSections(ast, uint8Buffer, \"start\");\r\n\r\n    var _deltaBytes = -(sectionMetadata.size.value + 1);\r\n    /* section id */\r\n\r\n\r\n    return {\r\n      uint8Buffer: uint8Buffer,\r\n      deltaBytes: _deltaBytes,\r\n      deltaElements: deltaElements\r\n    };\r\n  } // replacement is nothing\r\n\r\n\r\n  var replacement = [];\r\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\r\n  node.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\r\n  node.loc.end.column, replacement);\r\n  /**\r\n   * Update section\r\n   */\r\n  // $FlowIgnore: assertHasLoc ensures that\r\n\r\n  var deltaBytes = -(node.loc.end.column - node.loc.start.column);\r\n  return {\r\n    uint8Buffer: uint8Buffer,\r\n    deltaBytes: deltaBytes,\r\n    deltaElements: deltaElements\r\n  };\r\n}\r\n\r\nfunction applyAdd(ast, uint8Buffer, node) {\r\n  var deltaElements = +1; // since we added an element\r\n\r\n  var sectionName = getSectionForNode(node);\r\n  var sectionMetadata = getSectionMetadata(ast, sectionName); // Section doesn't exists, we create an empty one\r\n\r\n  if (typeof sectionMetadata === \"undefined\") {\r\n    var res = createEmptySection(ast, uint8Buffer, sectionName);\r\n    uint8Buffer = res.uint8Buffer;\r\n    sectionMetadata = res.sectionMetadata;\r\n  }\r\n  /**\r\n   * check that the expressions were ended\r\n   */\r\n\r\n\r\n  if (isFunc(node)) {\r\n    // $FlowIgnore\r\n    var body = node.body;\r\n\r\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\r\n      throw new Error(\"expressions must be ended\");\r\n    }\r\n  }\r\n\r\n  if (isGlobal(node)) {\r\n    // $FlowIgnore\r\n    var body = node.init;\r\n\r\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\r\n      throw new Error(\"expressions must be ended\");\r\n    }\r\n  }\r\n  /**\r\n   * Add nodes\r\n   */\r\n\r\n\r\n  var newByteArray = encodeNode(node); // The size of the section doesn't include the storage of the size itself\r\n  // we need to manually add it here\r\n\r\n  var start = getEndOfSection(sectionMetadata);\r\n  var end = start;\r\n  /**\r\n   * Update section\r\n   */\r\n\r\n  var deltaBytes = newByteArray.length;\r\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newByteArray);\r\n  node.loc = {\r\n    start: {\r\n      line: -1,\r\n      column: start\r\n    },\r\n    end: {\r\n      line: -1,\r\n      column: start + deltaBytes\r\n    }\r\n  }; // for func add the additional metadata in the AST\r\n\r\n  if (node.type === \"Func\") {\r\n    // the size is the first byte\r\n    // FIXME(sven): handle LEB128 correctly here\r\n    var bodySize = newByteArray[0];\r\n    node.metadata = {\r\n      bodySize: bodySize\r\n    };\r\n  }\r\n\r\n  if (node.type !== \"IndexInFuncSection\") {\r\n    orderedInsertNode(ast.body[0], node);\r\n  }\r\n\r\n  return {\r\n    uint8Buffer: uint8Buffer,\r\n    deltaBytes: deltaBytes,\r\n    deltaElements: deltaElements\r\n  };\r\n}\r\n\r\nexport function applyOperations(ast, uint8Buffer, ops) {\r\n  ops.forEach(function (op) {\r\n    var state;\r\n    var sectionName;\r\n\r\n    switch (op.kind) {\r\n      case \"update\":\r\n        state = applyUpdate(ast, uint8Buffer, [op.oldNode, op.node]);\r\n        sectionName = getSectionForNode(op.node);\r\n        break;\r\n\r\n      case \"delete\":\r\n        state = applyDelete(ast, uint8Buffer, op.node);\r\n        sectionName = getSectionForNode(op.node);\r\n        break;\r\n\r\n      case \"add\":\r\n        state = applyAdd(ast, uint8Buffer, op.node);\r\n        sectionName = getSectionForNode(op.node);\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"Unknown operation\");\r\n    }\r\n    /**\r\n     * Resize section vec size.\r\n     * If the length of the LEB-encoded size changes, this can change\r\n     * the byte length of the section and the offset for nodes in the\r\n     * section. So we do this first before resizing section byte size\r\n     * or shifting following operations' nodes.\r\n     */\r\n\r\n\r\n    if (state.deltaElements !== 0 && sectionName !== \"start\") {\r\n      var oldBufferLength = state.uint8Buffer.length;\r\n      state.uint8Buffer = resizeSectionVecSize(ast, state.uint8Buffer, sectionName, state.deltaElements); // Infer bytes added/removed by comparing buffer lengths\r\n\r\n      state.deltaBytes += state.uint8Buffer.length - oldBufferLength;\r\n    }\r\n    /**\r\n     * Resize section byte size.\r\n     * If the length of the LEB-encoded size changes, this can change\r\n     * the offset for nodes in the section. So we do this before\r\n     * shifting following operations' nodes.\r\n     */\r\n\r\n\r\n    if (state.deltaBytes !== 0 && sectionName !== \"start\") {\r\n      var _oldBufferLength = state.uint8Buffer.length;\r\n      state.uint8Buffer = resizeSectionByteSize(ast, state.uint8Buffer, sectionName, state.deltaBytes); // Infer bytes added/removed by comparing buffer lengths\r\n\r\n      state.deltaBytes += state.uint8Buffer.length - _oldBufferLength;\r\n    }\r\n    /**\r\n     * Shift following operation's nodes\r\n     */\r\n\r\n\r\n    if (state.deltaBytes !== 0) {\r\n      ops.forEach(function (op) {\r\n        // We don't need to handle add ops, they are positioning independent\r\n        switch (op.kind) {\r\n          case \"update\":\r\n            shiftLocNodeByDelta(op.oldNode, state.deltaBytes);\r\n            break;\r\n\r\n          case \"delete\":\r\n            shiftLocNodeByDelta(op.node, state.deltaBytes);\r\n            break;\r\n        }\r\n      });\r\n    }\r\n\r\n    uint8Buffer = state.uint8Buffer;\r\n  });\r\n  return uint8Buffer;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}