{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\nconst CONTINUATION_BIT = 0x20;\nconst createMappingsSerializer = options => {\n  const linesOnly = options && options.columns === false;\n  return linesOnly ? createLinesOnlyMappingsSerializer() : createFullMappingsSerializer();\n};\nconst createFullMappingsSerializer = () => {\n  let currentLine = 1;\n  let currentColumn = 0;\n  let currentSourceIndex = 0;\n  let currentOriginalLine = 1;\n  let currentOriginalColumn = 0;\n  let currentNameIndex = 0;\n  let activeMapping = false;\n  let activeName = false;\n  let initial = true;\n  return (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n    if (activeMapping && currentLine === generatedLine) {\n      // A mapping is still active\n      if (sourceIndex === currentSourceIndex && originalLine === currentOriginalLine && originalColumn === currentOriginalColumn && !activeName && nameIndex < 0) {\n        // avoid repeating the same original mapping\n        return \"\";\n      }\n    } else {\n      // No mapping is active\n      if (sourceIndex < 0) {\n        // avoid writing unneccessary generated mappings\n        return \"\";\n      }\n    }\n    let str;\n    if (currentLine < generatedLine) {\n      str = \";\".repeat(generatedLine - currentLine);\n      currentLine = generatedLine;\n      currentColumn = 0;\n      initial = false;\n    } else if (initial) {\n      str = \"\";\n      initial = false;\n    } else {\n      str = \",\";\n    }\n    const writeValue = value => {\n      const sign = value >>> 31 & 1;\n      const mask = value >> 31;\n      const absValue = value + mask ^ mask;\n      let data = absValue << 1 | sign;\n      for (;;) {\n        const sextet = data & 0x1f;\n        data >>= 5;\n        if (data === 0) {\n          str += ALPHABET[sextet];\n          break;\n        } else {\n          str += ALPHABET[sextet | CONTINUATION_BIT];\n        }\n      }\n    };\n    writeValue(generatedColumn - currentColumn);\n    currentColumn = generatedColumn;\n    if (sourceIndex >= 0) {\n      activeMapping = true;\n      if (sourceIndex === currentSourceIndex) {\n        str += \"A\";\n      } else {\n        writeValue(sourceIndex - currentSourceIndex);\n        currentSourceIndex = sourceIndex;\n      }\n      writeValue(originalLine - currentOriginalLine);\n      currentOriginalLine = originalLine;\n      if (originalColumn === currentOriginalColumn) {\n        str += \"A\";\n      } else {\n        writeValue(originalColumn - currentOriginalColumn);\n        currentOriginalColumn = originalColumn;\n      }\n      if (nameIndex >= 0) {\n        writeValue(nameIndex - currentNameIndex);\n        currentNameIndex = nameIndex;\n        activeName = true;\n      } else {\n        activeName = false;\n      }\n    } else {\n      activeMapping = false;\n    }\n    return str;\n  };\n};\nconst createLinesOnlyMappingsSerializer = () => {\n  let lastWrittenLine = 0;\n  let currentLine = 1;\n  let currentSourceIndex = 0;\n  let currentOriginalLine = 1;\n  return (generatedLine, _generatedColumn, sourceIndex, originalLine, _originalColumn, _nameIndex) => {\n    if (sourceIndex < 0) {\n      // avoid writing generated mappings at all\n      return \"\";\n    }\n    if (lastWrittenLine === generatedLine) {\n      // avoid writing multiple original mappings per line\n      return \"\";\n    }\n    let str;\n    const writeValue = value => {\n      const sign = value >>> 31 & 1;\n      const mask = value >> 31;\n      const absValue = value + mask ^ mask;\n      let data = absValue << 1 | sign;\n      for (;;) {\n        const sextet = data & 0x1f;\n        data >>= 5;\n        if (data === 0) {\n          str += ALPHABET[sextet];\n          break;\n        } else {\n          str += ALPHABET[sextet | CONTINUATION_BIT];\n        }\n      }\n    };\n    lastWrittenLine = generatedLine;\n    if (generatedLine === currentLine + 1) {\n      currentLine = generatedLine;\n      if (sourceIndex === currentSourceIndex) {\n        currentSourceIndex = sourceIndex;\n        if (originalLine === currentOriginalLine + 1) {\n          currentOriginalLine = originalLine;\n          return \";AACA\";\n        } else {\n          str = \";AA\";\n          writeValue(originalLine - currentOriginalLine);\n          currentOriginalLine = originalLine;\n          return str + \"A\";\n        }\n      } else {\n        str = \";A\";\n        writeValue(sourceIndex - currentSourceIndex);\n        currentSourceIndex = sourceIndex;\n        writeValue(originalLine - currentOriginalLine);\n        currentOriginalLine = originalLine;\n        return str + \"A\";\n      }\n    } else {\n      str = \";\".repeat(generatedLine - currentLine);\n      currentLine = generatedLine;\n      if (sourceIndex === currentSourceIndex) {\n        currentSourceIndex = sourceIndex;\n        if (originalLine === currentOriginalLine + 1) {\n          currentOriginalLine = originalLine;\n          return str + \"AACA\";\n        } else {\n          str += \"AA\";\n          writeValue(originalLine - currentOriginalLine);\n          currentOriginalLine = originalLine;\n          return str + \"A\";\n        }\n      } else {\n        str += \"A\";\n        writeValue(sourceIndex - currentSourceIndex);\n        currentSourceIndex = sourceIndex;\n        writeValue(originalLine - currentOriginalLine);\n        currentOriginalLine = originalLine;\n        return str + \"A\";\n      }\n    }\n  };\n};\nmodule.exports = createMappingsSerializer;","map":{"version":3,"names":["ALPHABET","split","CONTINUATION_BIT","createMappingsSerializer","options","linesOnly","columns","createLinesOnlyMappingsSerializer","createFullMappingsSerializer","currentLine","currentColumn","currentSourceIndex","currentOriginalLine","currentOriginalColumn","currentNameIndex","activeMapping","activeName","initial","generatedLine","generatedColumn","sourceIndex","originalLine","originalColumn","nameIndex","str","repeat","writeValue","value","sign","mask","absValue","data","sextet","lastWrittenLine","_generatedColumn","_originalColumn","_nameIndex","module","exports"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\r\n\t\"\"\r\n);\r\n\r\nconst CONTINUATION_BIT = 0x20;\r\n\r\nconst createMappingsSerializer = options => {\r\n\tconst linesOnly = options && options.columns === false;\r\n\treturn linesOnly\r\n\t\t? createLinesOnlyMappingsSerializer()\r\n\t\t: createFullMappingsSerializer();\r\n};\r\n\r\nconst createFullMappingsSerializer = () => {\r\n\tlet currentLine = 1;\r\n\tlet currentColumn = 0;\r\n\tlet currentSourceIndex = 0;\r\n\tlet currentOriginalLine = 1;\r\n\tlet currentOriginalColumn = 0;\r\n\tlet currentNameIndex = 0;\r\n\tlet activeMapping = false;\r\n\tlet activeName = false;\r\n\tlet initial = true;\r\n\treturn (\r\n\t\tgeneratedLine,\r\n\t\tgeneratedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\toriginalColumn,\r\n\t\tnameIndex\r\n\t) => {\r\n\t\tif (activeMapping && currentLine === generatedLine) {\r\n\t\t\t// A mapping is still active\r\n\t\t\tif (\r\n\t\t\t\tsourceIndex === currentSourceIndex &&\r\n\t\t\t\toriginalLine === currentOriginalLine &&\r\n\t\t\t\toriginalColumn === currentOriginalColumn &&\r\n\t\t\t\t!activeName &&\r\n\t\t\t\tnameIndex < 0\r\n\t\t\t) {\r\n\t\t\t\t// avoid repeating the same original mapping\r\n\t\t\t\treturn \"\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// No mapping is active\r\n\t\t\tif (sourceIndex < 0) {\r\n\t\t\t\t// avoid writing unneccessary generated mappings\r\n\t\t\t\treturn \"\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet str;\r\n\t\tif (currentLine < generatedLine) {\r\n\t\t\tstr = \";\".repeat(generatedLine - currentLine);\r\n\t\t\tcurrentLine = generatedLine;\r\n\t\t\tcurrentColumn = 0;\r\n\t\t\tinitial = false;\r\n\t\t} else if (initial) {\r\n\t\t\tstr = \"\";\r\n\t\t\tinitial = false;\r\n\t\t} else {\r\n\t\t\tstr = \",\";\r\n\t\t}\r\n\r\n\t\tconst writeValue = value => {\r\n\t\t\tconst sign = (value >>> 31) & 1;\r\n\t\t\tconst mask = value >> 31;\r\n\t\t\tconst absValue = (value + mask) ^ mask;\r\n\t\t\tlet data = (absValue << 1) | sign;\r\n\t\t\tfor (;;) {\r\n\t\t\t\tconst sextet = data & 0x1f;\r\n\t\t\t\tdata >>= 5;\r\n\t\t\t\tif (data === 0) {\r\n\t\t\t\t\tstr += ALPHABET[sextet];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstr += ALPHABET[sextet | CONTINUATION_BIT];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\twriteValue(generatedColumn - currentColumn);\r\n\t\tcurrentColumn = generatedColumn;\r\n\t\tif (sourceIndex >= 0) {\r\n\t\t\tactiveMapping = true;\r\n\t\t\tif (sourceIndex === currentSourceIndex) {\r\n\t\t\t\tstr += \"A\";\r\n\t\t\t} else {\r\n\t\t\t\twriteValue(sourceIndex - currentSourceIndex);\r\n\t\t\t\tcurrentSourceIndex = sourceIndex;\r\n\t\t\t}\r\n\t\t\twriteValue(originalLine - currentOriginalLine);\r\n\t\t\tcurrentOriginalLine = originalLine;\r\n\t\t\tif (originalColumn === currentOriginalColumn) {\r\n\t\t\t\tstr += \"A\";\r\n\t\t\t} else {\r\n\t\t\t\twriteValue(originalColumn - currentOriginalColumn);\r\n\t\t\t\tcurrentOriginalColumn = originalColumn;\r\n\t\t\t}\r\n\t\t\tif (nameIndex >= 0) {\r\n\t\t\t\twriteValue(nameIndex - currentNameIndex);\r\n\t\t\t\tcurrentNameIndex = nameIndex;\r\n\t\t\t\tactiveName = true;\r\n\t\t\t} else {\r\n\t\t\t\tactiveName = false;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tactiveMapping = false;\r\n\t\t}\r\n\t\treturn str;\r\n\t};\r\n};\r\n\r\nconst createLinesOnlyMappingsSerializer = () => {\r\n\tlet lastWrittenLine = 0;\r\n\tlet currentLine = 1;\r\n\tlet currentSourceIndex = 0;\r\n\tlet currentOriginalLine = 1;\r\n\treturn (\r\n\t\tgeneratedLine,\r\n\t\t_generatedColumn,\r\n\t\tsourceIndex,\r\n\t\toriginalLine,\r\n\t\t_originalColumn,\r\n\t\t_nameIndex\r\n\t) => {\r\n\t\tif (sourceIndex < 0) {\r\n\t\t\t// avoid writing generated mappings at all\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t\tif (lastWrittenLine === generatedLine) {\r\n\t\t\t// avoid writing multiple original mappings per line\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t\tlet str;\r\n\t\tconst writeValue = value => {\r\n\t\t\tconst sign = (value >>> 31) & 1;\r\n\t\t\tconst mask = value >> 31;\r\n\t\t\tconst absValue = (value + mask) ^ mask;\r\n\t\t\tlet data = (absValue << 1) | sign;\r\n\t\t\tfor (;;) {\r\n\t\t\t\tconst sextet = data & 0x1f;\r\n\t\t\t\tdata >>= 5;\r\n\t\t\t\tif (data === 0) {\r\n\t\t\t\t\tstr += ALPHABET[sextet];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstr += ALPHABET[sextet | CONTINUATION_BIT];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tlastWrittenLine = generatedLine;\r\n\t\tif (generatedLine === currentLine + 1) {\r\n\t\t\tcurrentLine = generatedLine;\r\n\t\t\tif (sourceIndex === currentSourceIndex) {\r\n\t\t\t\tcurrentSourceIndex = sourceIndex;\r\n\t\t\t\tif (originalLine === currentOriginalLine + 1) {\r\n\t\t\t\t\tcurrentOriginalLine = originalLine;\r\n\t\t\t\t\treturn \";AACA\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstr = \";AA\";\r\n\t\t\t\t\twriteValue(originalLine - currentOriginalLine);\r\n\t\t\t\t\tcurrentOriginalLine = originalLine;\r\n\t\t\t\t\treturn str + \"A\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstr = \";A\";\r\n\t\t\t\twriteValue(sourceIndex - currentSourceIndex);\r\n\t\t\t\tcurrentSourceIndex = sourceIndex;\r\n\t\t\t\twriteValue(originalLine - currentOriginalLine);\r\n\t\t\t\tcurrentOriginalLine = originalLine;\r\n\t\t\t\treturn str + \"A\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tstr = \";\".repeat(generatedLine - currentLine);\r\n\t\t\tcurrentLine = generatedLine;\r\n\t\t\tif (sourceIndex === currentSourceIndex) {\r\n\t\t\t\tcurrentSourceIndex = sourceIndex;\r\n\t\t\t\tif (originalLine === currentOriginalLine + 1) {\r\n\t\t\t\t\tcurrentOriginalLine = originalLine;\r\n\t\t\t\t\treturn str + \"AACA\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstr += \"AA\";\r\n\t\t\t\t\twriteValue(originalLine - currentOriginalLine);\r\n\t\t\t\t\tcurrentOriginalLine = originalLine;\r\n\t\t\t\t\treturn str + \"A\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstr += \"A\";\r\n\t\t\t\twriteValue(sourceIndex - currentSourceIndex);\r\n\t\t\t\tcurrentSourceIndex = sourceIndex;\r\n\t\t\t\twriteValue(originalLine - currentOriginalLine);\r\n\t\t\t\tcurrentOriginalLine = originalLine;\r\n\t\t\t\treturn str + \"A\";\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n};\r\n\r\nmodule.exports = createMappingsSerializer;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}