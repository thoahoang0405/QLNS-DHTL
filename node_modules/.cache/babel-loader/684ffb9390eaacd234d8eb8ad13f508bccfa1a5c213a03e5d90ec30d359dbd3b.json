{"ast":null,"code":"'use strict';\n\nconst hexify = char => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase();\n  return '0x' + (h.length % 2 ? '0' : '') + h;\n};\nconst parseError = (e, txt, context) => {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0\n    };\n  }\n  const badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i);\n  const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;\n  const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;\n  if (errIdx !== null && errIdx !== undefined) {\n    const start = errIdx <= context ? 0 : errIdx - context;\n    const end = errIdx + context >= txt.length ? txt.length : errIdx + context;\n    const slice = (start === 0 ? '' : '...') + txt.slice(start, end) + (end === txt.length ? '' : '...');\n    const near = txt === slice ? '' : 'near ';\n    return {\n      message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,\n      position: errIdx\n    };\n  } else {\n    return {\n      message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,\n      position: 0\n    };\n  }\n};\nclass JSONParseError extends SyntaxError {\n  constructor(er, txt, context, caller) {\n    context = context || 20;\n    const metadata = parseError(er, txt, context);\n    super(metadata.message);\n    Object.assign(this, metadata);\n    this.code = 'EJSONPARSE';\n    this.systemError = er;\n    Error.captureStackTrace(this, caller || this.constructor);\n  }\n  get name() {\n    return this.constructor.name;\n  }\n  set name(n) {}\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nconst kIndent = Symbol.for('indent');\nconst kNewline = Symbol.for('newline');\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nconst formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/;\nconst emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/;\nconst parseJson = (txt, reviver, context) => {\n  const parseText = stripBOM(txt);\n  context = context || 20;\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    const [, newline = '\\n', indent = '  '] = parseText.match(emptyRE) || parseText.match(formatRE) || [, '', ''];\n    const result = JSON.parse(parseText, reviver);\n    if (result && typeof result === 'object') {\n      result[kNewline] = newline;\n      result[kIndent] = indent;\n    }\n    return result;\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0;\n      throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? 'an empty array' : String(txt)}`), {\n        code: 'EJSONPARSE',\n        systemError: e\n      });\n    }\n    throw new JSONParseError(e, parseText, context, parseJson);\n  }\n};\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nconst stripBOM = txt => String(txt).replace(/^\\uFEFF/, '');\nmodule.exports = parseJson;\nparseJson.JSONParseError = JSONParseError;\nparseJson.noExceptions = (txt, reviver) => {\n  try {\n    return JSON.parse(stripBOM(txt), reviver);\n  } catch (e) {}\n};","map":{"version":3,"names":["hexify","char","h","charCodeAt","toString","toUpperCase","length","parseError","e","txt","context","message","position","badToken","match","errIdx","msg","replace","JSON","stringify","undefined","start","end","slice","near","JSONParseError","SyntaxError","constructor","er","caller","metadata","Object","assign","code","systemError","Error","captureStackTrace","name","n","Symbol","toStringTag","kIndent","for","kNewline","formatRE","emptyRE","parseJson","reviver","parseText","stripBOM","newline","indent","result","parse","Buffer","isBuffer","isEmptyArray","Array","isArray","TypeError","String","module","exports","noExceptions"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/json-parse-even-better-errors/index.js"],"sourcesContent":["'use strict'\r\n\r\nconst hexify = char => {\r\n  const h = char.charCodeAt(0).toString(16).toUpperCase()\r\n  return '0x' + (h.length % 2 ? '0' : '') + h\r\n}\r\n\r\nconst parseError = (e, txt, context) => {\r\n  if (!txt) {\r\n    return {\r\n      message: e.message + ' while parsing empty string',\r\n      position: 0,\r\n    }\r\n  }\r\n  const badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i)\r\n  const errIdx = badToken ? +badToken[2]\r\n    : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1\r\n    : null\r\n\r\n  const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${\r\n      JSON.stringify(badToken[1])\r\n    } (${hexify(badToken[1])})`)\r\n    : e.message\r\n\r\n  if (errIdx !== null && errIdx !== undefined) {\r\n    const start = errIdx <= context ? 0\r\n      : errIdx - context\r\n\r\n    const end = errIdx + context >= txt.length ? txt.length\r\n      : errIdx + context\r\n\r\n    const slice = (start === 0 ? '' : '...') +\r\n      txt.slice(start, end) +\r\n      (end === txt.length ? '' : '...')\r\n\r\n    const near = txt === slice ? '' : 'near '\r\n\r\n    return {\r\n      message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,\r\n      position: errIdx,\r\n    }\r\n  } else {\r\n    return {\r\n      message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,\r\n      position: 0,\r\n    }\r\n  }\r\n}\r\n\r\nclass JSONParseError extends SyntaxError {\r\n  constructor (er, txt, context, caller) {\r\n    context = context || 20\r\n    const metadata = parseError(er, txt, context)\r\n    super(metadata.message)\r\n    Object.assign(this, metadata)\r\n    this.code = 'EJSONPARSE'\r\n    this.systemError = er\r\n    Error.captureStackTrace(this, caller || this.constructor)\r\n  }\r\n  get name () { return this.constructor.name }\r\n  set name (n) {}\r\n  get [Symbol.toStringTag] () { return this.constructor.name }\r\n}\r\n\r\nconst kIndent = Symbol.for('indent')\r\nconst kNewline = Symbol.for('newline')\r\n// only respect indentation if we got a line break, otherwise squash it\r\n// things other than objects and arrays aren't indented, so ignore those\r\n// Important: in both of these regexps, the $1 capture group is the newline\r\n// or undefined, and the $2 capture group is the indent, or undefined.\r\nconst formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/\r\nconst emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/\r\n\r\nconst parseJson = (txt, reviver, context) => {\r\n  const parseText = stripBOM(txt)\r\n  context = context || 20\r\n  try {\r\n    // get the indentation so that we can save it back nicely\r\n    // if the file starts with {\" then we have an indent of '', ie, none\r\n    // otherwise, pick the indentation of the next line after the first \\n\r\n    // If the pattern doesn't match, then it means no indentation.\r\n    // JSON.stringify ignores symbols, so this is reasonably safe.\r\n    // if the string is '{}' or '[]', then use the default 2-space indent.\r\n    const [, newline = '\\n', indent = '  '] = parseText.match(emptyRE) ||\r\n      parseText.match(formatRE) ||\r\n      [, '', '']\r\n\r\n    const result = JSON.parse(parseText, reviver)\r\n    if (result && typeof result === 'object') {\r\n      result[kNewline] = newline\r\n      result[kIndent] = indent\r\n    }\r\n    return result\r\n  } catch (e) {\r\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\r\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0\r\n      throw Object.assign(new TypeError(\r\n        `Cannot parse ${isEmptyArray ? 'an empty array' : String(txt)}`\r\n      ), {\r\n        code: 'EJSONPARSE',\r\n        systemError: e,\r\n      })\r\n    }\r\n\r\n    throw new JSONParseError(e, parseText, context, parseJson)\r\n  }\r\n}\r\n\r\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\r\n// because the buffer-to-string conversion in `fs.readFileSync()`\r\n// translates it to FEFF, the UTF-16 BOM.\r\nconst stripBOM = txt => String(txt).replace(/^\\uFEFF/, '')\r\n\r\nmodule.exports = parseJson\r\nparseJson.JSONParseError = JSONParseError\r\n\r\nparseJson.noExceptions = (txt, reviver) => {\r\n  try {\r\n    return JSON.parse(stripBOM(txt), reviver)\r\n  } catch (e) {}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}