{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\r\n * leb: LEB128 utilities.\r\n */\n\n/*\r\n * Modules used\r\n */\n\"use strict\";\n\nimport Long from \"@xtuc/long\";\nimport * as bits from \"./bits\";\nimport * as bufs from \"./bufs\";\n/*\r\n * Module variables\r\n */\n\n/** The minimum possible 32-bit signed int. */\n\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\r\n * The maximum possible 64-bit signed int that is representable as a\r\n * JavaScript number.\r\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\r\n * The maximum possible 64-bit unsigned int that is representable as a\r\n * JavaScript number.\r\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\r\n * Helper functions\r\n */\n\n/**\r\n * Determines the number of bits required to encode the number\r\n * represented in the given buffer as a signed value. The buffer is\r\n * taken to represent a signed number in little-endian form.\r\n *\r\n * The number of bits to encode is the (zero-based) bit number of the\r\n * highest-order non-sign-matching bit, plus two. For example:\r\n *\r\n *   11111011 01110101\r\n *   high          low\r\n *\r\n * The sign bit here is 1 (that is, it's a negative number). The highest\r\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\r\n * bit is bit #0). So, we have to encode at least 12 bits total.\r\n *\r\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\r\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\r\n * Determines the number of bits required to encode the number\r\n * represented in the given buffer as an unsigned value. The buffer is\r\n * taken to represent an unsigned number in little-endian form.\r\n *\r\n * The number of bits to encode is the (zero-based) bit number of the\r\n * highest-order 1 bit, plus one. For example:\r\n *\r\n *   00011000 01010011\r\n *   high          low\r\n *\r\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\r\n * is bit #0). So, we have to encode at least 13 bits total.\r\n *\r\n * As a special degenerate case, the number 0 requires 1 bit.\r\n */\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\r\n * Common encoder for both signed and unsigned ints. This takes a\r\n * bigint-ish buffer, returning an LEB128-encoded buffer.\r\n */\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\r\n * Gets the byte-length of the value encoded in the given buffer at\r\n * the given index.\r\n */\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n  return result;\n}\n/**\r\n * Common decoder for both signed and unsigned ints. This takes an\r\n * LEB128-encoded buffer, returning a bigint-ish buffer.\r\n */\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n  var signBit;\n  var signByte;\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\r\n * Exported bindings\r\n */\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\nfunction encodeInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeInt32LE(num, 0);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, false);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\nfunction encodeUInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeUInt32LE(num, 0);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, true);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\nexport default {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};","map":{"version":3,"names":["Long","bits","bufs","MIN_INT32","MAX_INT32","MAX_UINT32","signedBitCount","buffer","highOrder","getSign","unsignedBitCount","result","encodeBufferCommon","signed","signBit","bitCount","byteCount","Math","ceil","alloc","i","payload","extract","encodedLength","encodedBuffer","index","length","decodeBufferCommon","undefined","bitLength","byteLength","outIndex","inject","signByte","lastByte","endBit","shift","resize","value","nextIndex","encodeIntBuffer","decodeIntBuffer","encodeInt32","num","buf","writeInt32LE","free","decodeInt32","parsed","readInt","Error","encodeInt64","writeInt64","decodeInt64","fromBytesLE","lossy","encodeUIntBuffer","decodeUIntBuffer","encodeUInt32","writeUInt32LE","decodeUInt32","readUInt","encodeUInt64","writeUInt64","decodeUInt64"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/@webassemblyjs/leb128/esm/leb.js"],"sourcesContent":["// Copyright 2012 The Obvious Corporation.\r\n\r\n/*\r\n * leb: LEB128 utilities.\r\n */\r\n\r\n/*\r\n * Modules used\r\n */\r\n\"use strict\";\r\n\r\nimport Long from \"@xtuc/long\";\r\nimport * as bits from \"./bits\";\r\nimport * as bufs from \"./bufs\";\r\n/*\r\n * Module variables\r\n */\r\n\r\n/** The minimum possible 32-bit signed int. */\r\n\r\nvar MIN_INT32 = -0x80000000;\r\n/** The maximum possible 32-bit signed int. */\r\n\r\nvar MAX_INT32 = 0x7fffffff;\r\n/** The maximum possible 32-bit unsigned int. */\r\n\r\nvar MAX_UINT32 = 0xffffffff;\r\n/** The minimum possible 64-bit signed int. */\r\n// const MIN_INT64 = -0x8000000000000000;\r\n\r\n/**\r\n * The maximum possible 64-bit signed int that is representable as a\r\n * JavaScript number.\r\n */\r\n// const MAX_INT64 = 0x7ffffffffffffc00;\r\n\r\n/**\r\n * The maximum possible 64-bit unsigned int that is representable as a\r\n * JavaScript number.\r\n */\r\n// const MAX_UINT64 = 0xfffffffffffff800;\r\n\r\n/*\r\n * Helper functions\r\n */\r\n\r\n/**\r\n * Determines the number of bits required to encode the number\r\n * represented in the given buffer as a signed value. The buffer is\r\n * taken to represent a signed number in little-endian form.\r\n *\r\n * The number of bits to encode is the (zero-based) bit number of the\r\n * highest-order non-sign-matching bit, plus two. For example:\r\n *\r\n *   11111011 01110101\r\n *   high          low\r\n *\r\n * The sign bit here is 1 (that is, it's a negative number). The highest\r\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\r\n * bit is bit #0). So, we have to encode at least 12 bits total.\r\n *\r\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\r\n */\r\n\r\nfunction signedBitCount(buffer) {\r\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\r\n}\r\n/**\r\n * Determines the number of bits required to encode the number\r\n * represented in the given buffer as an unsigned value. The buffer is\r\n * taken to represent an unsigned number in little-endian form.\r\n *\r\n * The number of bits to encode is the (zero-based) bit number of the\r\n * highest-order 1 bit, plus one. For example:\r\n *\r\n *   00011000 01010011\r\n *   high          low\r\n *\r\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\r\n * is bit #0). So, we have to encode at least 13 bits total.\r\n *\r\n * As a special degenerate case, the number 0 requires 1 bit.\r\n */\r\n\r\n\r\nfunction unsignedBitCount(buffer) {\r\n  var result = bits.highOrder(1, buffer) + 1;\r\n  return result ? result : 1;\r\n}\r\n/**\r\n * Common encoder for both signed and unsigned ints. This takes a\r\n * bigint-ish buffer, returning an LEB128-encoded buffer.\r\n */\r\n\r\n\r\nfunction encodeBufferCommon(buffer, signed) {\r\n  var signBit;\r\n  var bitCount;\r\n\r\n  if (signed) {\r\n    signBit = bits.getSign(buffer);\r\n    bitCount = signedBitCount(buffer);\r\n  } else {\r\n    signBit = 0;\r\n    bitCount = unsignedBitCount(buffer);\r\n  }\r\n\r\n  var byteCount = Math.ceil(bitCount / 7);\r\n  var result = bufs.alloc(byteCount);\r\n\r\n  for (var i = 0; i < byteCount; i++) {\r\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\r\n    result[i] = payload | 0x80;\r\n  } // Mask off the top bit of the last byte, to indicate the end of the\r\n  // encoding.\r\n\r\n\r\n  result[byteCount - 1] &= 0x7f;\r\n  return result;\r\n}\r\n/**\r\n * Gets the byte-length of the value encoded in the given buffer at\r\n * the given index.\r\n */\r\n\r\n\r\nfunction encodedLength(encodedBuffer, index) {\r\n  var result = 0;\r\n\r\n  while (encodedBuffer[index + result] >= 0x80) {\r\n    result++;\r\n  }\r\n\r\n  result++; // to account for the last byte\r\n\r\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\r\n    // throw new Error(\"integer representation too long\");\r\n  }\r\n\r\n  return result;\r\n}\r\n/**\r\n * Common decoder for both signed and unsigned ints. This takes an\r\n * LEB128-encoded buffer, returning a bigint-ish buffer.\r\n */\r\n\r\n\r\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\r\n  index = index === undefined ? 0 : index;\r\n  var length = encodedLength(encodedBuffer, index);\r\n  var bitLength = length * 7;\r\n  var byteLength = Math.ceil(bitLength / 8);\r\n  var result = bufs.alloc(byteLength);\r\n  var outIndex = 0;\r\n\r\n  while (length > 0) {\r\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\r\n    outIndex += 7;\r\n    index++;\r\n    length--;\r\n  }\r\n\r\n  var signBit;\r\n  var signByte;\r\n\r\n  if (signed) {\r\n    // Sign-extend the last byte.\r\n    var lastByte = result[byteLength - 1];\r\n    var endBit = outIndex % 8;\r\n\r\n    if (endBit !== 0) {\r\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\r\n\r\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\r\n    }\r\n\r\n    signBit = lastByte >> 7;\r\n    signByte = signBit * 0xff;\r\n  } else {\r\n    signBit = 0;\r\n    signByte = 0;\r\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\r\n  // bits (because the value would be the same if they were removed).\r\n\r\n\r\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\r\n    byteLength--;\r\n  }\r\n\r\n  result = bufs.resize(result, byteLength);\r\n  return {\r\n    value: result,\r\n    nextIndex: index\r\n  };\r\n}\r\n/*\r\n * Exported bindings\r\n */\r\n\r\n\r\nfunction encodeIntBuffer(buffer) {\r\n  return encodeBufferCommon(buffer, true);\r\n}\r\n\r\nfunction decodeIntBuffer(encodedBuffer, index) {\r\n  return decodeBufferCommon(encodedBuffer, index, true);\r\n}\r\n\r\nfunction encodeInt32(num) {\r\n  var buf = bufs.alloc(4);\r\n  buf.writeInt32LE(num, 0);\r\n  var result = encodeIntBuffer(buf);\r\n  bufs.free(buf);\r\n  return result;\r\n}\r\n\r\nfunction decodeInt32(encodedBuffer, index) {\r\n  var result = decodeIntBuffer(encodedBuffer, index);\r\n  var parsed = bufs.readInt(result.value);\r\n  var value = parsed.value;\r\n  bufs.free(result.value);\r\n\r\n  if (value < MIN_INT32 || value > MAX_INT32) {\r\n    throw new Error(\"integer too large\");\r\n  }\r\n\r\n  return {\r\n    value: value,\r\n    nextIndex: result.nextIndex\r\n  };\r\n}\r\n\r\nfunction encodeInt64(num) {\r\n  var buf = bufs.alloc(8);\r\n  bufs.writeInt64(num, buf);\r\n  var result = encodeIntBuffer(buf);\r\n  bufs.free(buf);\r\n  return result;\r\n}\r\n\r\nfunction decodeInt64(encodedBuffer, index) {\r\n  var result = decodeIntBuffer(encodedBuffer, index);\r\n  var value = Long.fromBytesLE(result.value, false);\r\n  bufs.free(result.value);\r\n  return {\r\n    value: value,\r\n    nextIndex: result.nextIndex,\r\n    lossy: false\r\n  };\r\n}\r\n\r\nfunction encodeUIntBuffer(buffer) {\r\n  return encodeBufferCommon(buffer, false);\r\n}\r\n\r\nfunction decodeUIntBuffer(encodedBuffer, index) {\r\n  return decodeBufferCommon(encodedBuffer, index, false);\r\n}\r\n\r\nfunction encodeUInt32(num) {\r\n  var buf = bufs.alloc(4);\r\n  buf.writeUInt32LE(num, 0);\r\n  var result = encodeUIntBuffer(buf);\r\n  bufs.free(buf);\r\n  return result;\r\n}\r\n\r\nfunction decodeUInt32(encodedBuffer, index) {\r\n  var result = decodeUIntBuffer(encodedBuffer, index);\r\n  var parsed = bufs.readUInt(result.value);\r\n  var value = parsed.value;\r\n  bufs.free(result.value);\r\n\r\n  if (value > MAX_UINT32) {\r\n    throw new Error(\"integer too large\");\r\n  }\r\n\r\n  return {\r\n    value: value,\r\n    nextIndex: result.nextIndex\r\n  };\r\n}\r\n\r\nfunction encodeUInt64(num) {\r\n  var buf = bufs.alloc(8);\r\n  bufs.writeUInt64(num, buf);\r\n  var result = encodeUIntBuffer(buf);\r\n  bufs.free(buf);\r\n  return result;\r\n}\r\n\r\nfunction decodeUInt64(encodedBuffer, index) {\r\n  var result = decodeUIntBuffer(encodedBuffer, index);\r\n  var value = Long.fromBytesLE(result.value, true);\r\n  bufs.free(result.value);\r\n  return {\r\n    value: value,\r\n    nextIndex: result.nextIndex,\r\n    lossy: false\r\n  };\r\n}\r\n\r\nexport default {\r\n  decodeInt32: decodeInt32,\r\n  decodeInt64: decodeInt64,\r\n  decodeIntBuffer: decodeIntBuffer,\r\n  decodeUInt32: decodeUInt32,\r\n  decodeUInt64: decodeUInt64,\r\n  decodeUIntBuffer: decodeUIntBuffer,\r\n  encodeInt32: encodeInt32,\r\n  encodeInt64: encodeInt64,\r\n  encodeIntBuffer: encodeIntBuffer,\r\n  encodeUInt32: encodeUInt32,\r\n  encodeUInt64: encodeUInt64,\r\n  encodeUIntBuffer: encodeUIntBuffer\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}