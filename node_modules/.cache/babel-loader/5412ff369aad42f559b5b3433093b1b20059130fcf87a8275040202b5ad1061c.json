{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst path = require(\"path\");\n\n/**\r\n * @template T\r\n * @typedef {Object} TreeNode\r\n * @property {string} filePath\r\n * @property {TreeNode} parent\r\n * @property {TreeNode[]} children\r\n * @property {number} entries\r\n * @property {boolean} active\r\n * @property {T[] | T | undefined} value\r\n */\n\n/**\r\n * @template T\r\n * @param {Map<string, T[] | T} plan\r\n * @param {number} limit\r\n * @returns {Map<string, Map<T, string>>} the new plan\r\n */\nmodule.exports = (plan, limit) => {\n  const treeMap = new Map();\n  // Convert to tree\n  for (const [filePath, value] of plan) {\n    treeMap.set(filePath, {\n      filePath,\n      parent: undefined,\n      children: undefined,\n      entries: 1,\n      active: true,\n      value\n    });\n  }\n  let currentCount = treeMap.size;\n  // Create parents and calculate sum of entries\n  for (const node of treeMap.values()) {\n    const parentPath = path.dirname(node.filePath);\n    if (parentPath !== node.filePath) {\n      let parent = treeMap.get(parentPath);\n      if (parent === undefined) {\n        parent = {\n          filePath: parentPath,\n          parent: undefined,\n          children: [node],\n          entries: node.entries,\n          active: false,\n          value: undefined\n        };\n        treeMap.set(parentPath, parent);\n        node.parent = parent;\n      } else {\n        node.parent = parent;\n        if (parent.children === undefined) {\n          parent.children = [node];\n        } else {\n          parent.children.push(node);\n        }\n        do {\n          parent.entries += node.entries;\n          parent = parent.parent;\n        } while (parent);\n      }\n    }\n  }\n  // Reduce until limit reached\n  while (currentCount > limit) {\n    // Select node that helps reaching the limit most effectively without overmerging\n    const overLimit = currentCount - limit;\n    let bestNode = undefined;\n    let bestCost = Infinity;\n    for (const node of treeMap.values()) {\n      if (node.entries <= 1 || !node.children || !node.parent) continue;\n      if (node.children.length === 0) continue;\n      if (node.children.length === 1 && !node.value) continue;\n      // Try to select the node with has just a bit more entries than we need to reduce\n      // When just a bit more is over 30% over the limit,\n      // also consider just a bit less entries then we need to reduce\n      const cost = node.entries - 1 >= overLimit ? node.entries - 1 - overLimit : overLimit - node.entries + 1 + limit * 0.3;\n      if (cost < bestCost) {\n        bestNode = node;\n        bestCost = cost;\n      }\n    }\n    if (!bestNode) break;\n    // Merge all children\n    const reduction = bestNode.entries - 1;\n    bestNode.active = true;\n    bestNode.entries = 1;\n    currentCount -= reduction;\n    let parent = bestNode.parent;\n    while (parent) {\n      parent.entries -= reduction;\n      parent = parent.parent;\n    }\n    const queue = new Set(bestNode.children);\n    for (const node of queue) {\n      node.active = false;\n      node.entries = 0;\n      if (node.children) {\n        for (const child of node.children) queue.add(child);\n      }\n    }\n  }\n  // Write down new plan\n  const newPlan = new Map();\n  for (const rootNode of treeMap.values()) {\n    if (!rootNode.active) continue;\n    const map = new Map();\n    const queue = new Set([rootNode]);\n    for (const node of queue) {\n      if (node.active && node !== rootNode) continue;\n      if (node.value) {\n        if (Array.isArray(node.value)) {\n          for (const item of node.value) {\n            map.set(item, node.filePath);\n          }\n        } else {\n          map.set(node.value, node.filePath);\n        }\n      }\n      if (node.children) {\n        for (const child of node.children) {\n          queue.add(child);\n        }\n      }\n    }\n    newPlan.set(rootNode.filePath, map);\n  }\n  return newPlan;\n};","map":{"version":3,"names":["require","path","module","exports","plan","limit","treeMap","Map","filePath","value","set","parent","undefined","children","entries","active","currentCount","size","node","values","parentPath","dirname","get","push","overLimit","bestNode","bestCost","Infinity","length","cost","reduction","queue","Set","child","add","newPlan","rootNode","map","Array","isArray","item"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/watchpack/lib/reducePlan.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nconst path = require(\"path\");\r\n\r\n/**\r\n * @template T\r\n * @typedef {Object} TreeNode\r\n * @property {string} filePath\r\n * @property {TreeNode} parent\r\n * @property {TreeNode[]} children\r\n * @property {number} entries\r\n * @property {boolean} active\r\n * @property {T[] | T | undefined} value\r\n */\r\n\r\n/**\r\n * @template T\r\n * @param {Map<string, T[] | T} plan\r\n * @param {number} limit\r\n * @returns {Map<string, Map<T, string>>} the new plan\r\n */\r\nmodule.exports = (plan, limit) => {\r\n\tconst treeMap = new Map();\r\n\t// Convert to tree\r\n\tfor (const [filePath, value] of plan) {\r\n\t\ttreeMap.set(filePath, {\r\n\t\t\tfilePath,\r\n\t\t\tparent: undefined,\r\n\t\t\tchildren: undefined,\r\n\t\t\tentries: 1,\r\n\t\t\tactive: true,\r\n\t\t\tvalue\r\n\t\t});\r\n\t}\r\n\tlet currentCount = treeMap.size;\r\n\t// Create parents and calculate sum of entries\r\n\tfor (const node of treeMap.values()) {\r\n\t\tconst parentPath = path.dirname(node.filePath);\r\n\t\tif (parentPath !== node.filePath) {\r\n\t\t\tlet parent = treeMap.get(parentPath);\r\n\t\t\tif (parent === undefined) {\r\n\t\t\t\tparent = {\r\n\t\t\t\t\tfilePath: parentPath,\r\n\t\t\t\t\tparent: undefined,\r\n\t\t\t\t\tchildren: [node],\r\n\t\t\t\t\tentries: node.entries,\r\n\t\t\t\t\tactive: false,\r\n\t\t\t\t\tvalue: undefined\r\n\t\t\t\t};\r\n\t\t\t\ttreeMap.set(parentPath, parent);\r\n\t\t\t\tnode.parent = parent;\r\n\t\t\t} else {\r\n\t\t\t\tnode.parent = parent;\r\n\t\t\t\tif (parent.children === undefined) {\r\n\t\t\t\t\tparent.children = [node];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparent.children.push(node);\r\n\t\t\t\t}\r\n\t\t\t\tdo {\r\n\t\t\t\t\tparent.entries += node.entries;\r\n\t\t\t\t\tparent = parent.parent;\r\n\t\t\t\t} while (parent);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Reduce until limit reached\r\n\twhile (currentCount > limit) {\r\n\t\t// Select node that helps reaching the limit most effectively without overmerging\r\n\t\tconst overLimit = currentCount - limit;\r\n\t\tlet bestNode = undefined;\r\n\t\tlet bestCost = Infinity;\r\n\t\tfor (const node of treeMap.values()) {\r\n\t\t\tif (node.entries <= 1 || !node.children || !node.parent) continue;\r\n\t\t\tif (node.children.length === 0) continue;\r\n\t\t\tif (node.children.length === 1 && !node.value) continue;\r\n\t\t\t// Try to select the node with has just a bit more entries than we need to reduce\r\n\t\t\t// When just a bit more is over 30% over the limit,\r\n\t\t\t// also consider just a bit less entries then we need to reduce\r\n\t\t\tconst cost =\r\n\t\t\t\tnode.entries - 1 >= overLimit\r\n\t\t\t\t\t? node.entries - 1 - overLimit\r\n\t\t\t\t\t: overLimit - node.entries + 1 + limit * 0.3;\r\n\t\t\tif (cost < bestCost) {\r\n\t\t\t\tbestNode = node;\r\n\t\t\t\tbestCost = cost;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!bestNode) break;\r\n\t\t// Merge all children\r\n\t\tconst reduction = bestNode.entries - 1;\r\n\t\tbestNode.active = true;\r\n\t\tbestNode.entries = 1;\r\n\t\tcurrentCount -= reduction;\r\n\t\tlet parent = bestNode.parent;\r\n\t\twhile (parent) {\r\n\t\t\tparent.entries -= reduction;\r\n\t\t\tparent = parent.parent;\r\n\t\t}\r\n\t\tconst queue = new Set(bestNode.children);\r\n\t\tfor (const node of queue) {\r\n\t\t\tnode.active = false;\r\n\t\t\tnode.entries = 0;\r\n\t\t\tif (node.children) {\r\n\t\t\t\tfor (const child of node.children) queue.add(child);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Write down new plan\r\n\tconst newPlan = new Map();\r\n\tfor (const rootNode of treeMap.values()) {\r\n\t\tif (!rootNode.active) continue;\r\n\t\tconst map = new Map();\r\n\t\tconst queue = new Set([rootNode]);\r\n\t\tfor (const node of queue) {\r\n\t\t\tif (node.active && node !== rootNode) continue;\r\n\t\t\tif (node.value) {\r\n\t\t\t\tif (Array.isArray(node.value)) {\r\n\t\t\t\t\tfor (const item of node.value) {\r\n\t\t\t\t\t\tmap.set(item, node.filePath);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmap.set(node.value, node.filePath);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (node.children) {\r\n\t\t\t\tfor (const child of node.children) {\r\n\t\t\t\t\tqueue.add(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tnewPlan.set(rootNode.filePath, map);\r\n\t}\r\n\treturn newPlan;\r\n};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAACA,OAAA;AAEb,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAE,MAAM,CAACC,OAAO,GAAG,CAACC,IAAI,EAAEC,KAAK,KAAK;EACjC,MAAMC,OAAO,GAAG,IAAIC,GAAG,EAAE;EACzB;EACA,KAAK,MAAM,CAACC,QAAQ,EAAEC,KAAK,CAAC,IAAIL,IAAI,EAAE;IACrCE,OAAO,CAACI,GAAG,CAACF,QAAQ,EAAE;MACrBA,QAAQ;MACRG,MAAM,EAAEC,SAAS;MACjBC,QAAQ,EAAED,SAAS;MACnBE,OAAO,EAAE,CAAC;MACVC,MAAM,EAAE,IAAI;MACZN;IACD,CAAC,CAAC;EACH;EACA,IAAIO,YAAY,GAAGV,OAAO,CAACW,IAAI;EAC/B;EACA,KAAK,MAAMC,IAAI,IAAIZ,OAAO,CAACa,MAAM,EAAE,EAAE;IACpC,MAAMC,UAAU,GAAGnB,IAAI,CAACoB,OAAO,CAACH,IAAI,CAACV,QAAQ,CAAC;IAC9C,IAAIY,UAAU,KAAKF,IAAI,CAACV,QAAQ,EAAE;MACjC,IAAIG,MAAM,GAAGL,OAAO,CAACgB,GAAG,CAACF,UAAU,CAAC;MACpC,IAAIT,MAAM,KAAKC,SAAS,EAAE;QACzBD,MAAM,GAAG;UACRH,QAAQ,EAAEY,UAAU;UACpBT,MAAM,EAAEC,SAAS;UACjBC,QAAQ,EAAE,CAACK,IAAI,CAAC;UAChBJ,OAAO,EAAEI,IAAI,CAACJ,OAAO;UACrBC,MAAM,EAAE,KAAK;UACbN,KAAK,EAAEG;QACR,CAAC;QACDN,OAAO,CAACI,GAAG,CAACU,UAAU,EAAET,MAAM,CAAC;QAC/BO,IAAI,CAACP,MAAM,GAAGA,MAAM;MACrB,CAAC,MAAM;QACNO,IAAI,CAACP,MAAM,GAAGA,MAAM;QACpB,IAAIA,MAAM,CAACE,QAAQ,KAAKD,SAAS,EAAE;UAClCD,MAAM,CAACE,QAAQ,GAAG,CAACK,IAAI,CAAC;QACzB,CAAC,MAAM;UACNP,MAAM,CAACE,QAAQ,CAACU,IAAI,CAACL,IAAI,CAAC;QAC3B;QACA,GAAG;UACFP,MAAM,CAACG,OAAO,IAAII,IAAI,CAACJ,OAAO;UAC9BH,MAAM,GAAGA,MAAM,CAACA,MAAM;QACvB,CAAC,QAAQA,MAAM;MAChB;IACD;EACD;EACA;EACA,OAAOK,YAAY,GAAGX,KAAK,EAAE;IAC5B;IACA,MAAMmB,SAAS,GAAGR,YAAY,GAAGX,KAAK;IACtC,IAAIoB,QAAQ,GAAGb,SAAS;IACxB,IAAIc,QAAQ,GAAGC,QAAQ;IACvB,KAAK,MAAMT,IAAI,IAAIZ,OAAO,CAACa,MAAM,EAAE,EAAE;MACpC,IAAID,IAAI,CAACJ,OAAO,IAAI,CAAC,IAAI,CAACI,IAAI,CAACL,QAAQ,IAAI,CAACK,IAAI,CAACP,MAAM,EAAE;MACzD,IAAIO,IAAI,CAACL,QAAQ,CAACe,MAAM,KAAK,CAAC,EAAE;MAChC,IAAIV,IAAI,CAACL,QAAQ,CAACe,MAAM,KAAK,CAAC,IAAI,CAACV,IAAI,CAACT,KAAK,EAAE;MAC/C;MACA;MACA;MACA,MAAMoB,IAAI,GACTX,IAAI,CAACJ,OAAO,GAAG,CAAC,IAAIU,SAAS,GAC1BN,IAAI,CAACJ,OAAO,GAAG,CAAC,GAAGU,SAAS,GAC5BA,SAAS,GAAGN,IAAI,CAACJ,OAAO,GAAG,CAAC,GAAGT,KAAK,GAAG,GAAG;MAC9C,IAAIwB,IAAI,GAAGH,QAAQ,EAAE;QACpBD,QAAQ,GAAGP,IAAI;QACfQ,QAAQ,GAAGG,IAAI;MAChB;IACD;IACA,IAAI,CAACJ,QAAQ,EAAE;IACf;IACA,MAAMK,SAAS,GAAGL,QAAQ,CAACX,OAAO,GAAG,CAAC;IACtCW,QAAQ,CAACV,MAAM,GAAG,IAAI;IACtBU,QAAQ,CAACX,OAAO,GAAG,CAAC;IACpBE,YAAY,IAAIc,SAAS;IACzB,IAAInB,MAAM,GAAGc,QAAQ,CAACd,MAAM;IAC5B,OAAOA,MAAM,EAAE;MACdA,MAAM,CAACG,OAAO,IAAIgB,SAAS;MAC3BnB,MAAM,GAAGA,MAAM,CAACA,MAAM;IACvB;IACA,MAAMoB,KAAK,GAAG,IAAIC,GAAG,CAACP,QAAQ,CAACZ,QAAQ,CAAC;IACxC,KAAK,MAAMK,IAAI,IAAIa,KAAK,EAAE;MACzBb,IAAI,CAACH,MAAM,GAAG,KAAK;MACnBG,IAAI,CAACJ,OAAO,GAAG,CAAC;MAChB,IAAII,IAAI,CAACL,QAAQ,EAAE;QAClB,KAAK,MAAMoB,KAAK,IAAIf,IAAI,CAACL,QAAQ,EAAEkB,KAAK,CAACG,GAAG,CAACD,KAAK,CAAC;MACpD;IACD;EACD;EACA;EACA,MAAME,OAAO,GAAG,IAAI5B,GAAG,EAAE;EACzB,KAAK,MAAM6B,QAAQ,IAAI9B,OAAO,CAACa,MAAM,EAAE,EAAE;IACxC,IAAI,CAACiB,QAAQ,CAACrB,MAAM,EAAE;IACtB,MAAMsB,GAAG,GAAG,IAAI9B,GAAG,EAAE;IACrB,MAAMwB,KAAK,GAAG,IAAIC,GAAG,CAAC,CAACI,QAAQ,CAAC,CAAC;IACjC,KAAK,MAAMlB,IAAI,IAAIa,KAAK,EAAE;MACzB,IAAIb,IAAI,CAACH,MAAM,IAAIG,IAAI,KAAKkB,QAAQ,EAAE;MACtC,IAAIlB,IAAI,CAACT,KAAK,EAAE;QACf,IAAI6B,KAAK,CAACC,OAAO,CAACrB,IAAI,CAACT,KAAK,CAAC,EAAE;UAC9B,KAAK,MAAM+B,IAAI,IAAItB,IAAI,CAACT,KAAK,EAAE;YAC9B4B,GAAG,CAAC3B,GAAG,CAAC8B,IAAI,EAAEtB,IAAI,CAACV,QAAQ,CAAC;UAC7B;QACD,CAAC,MAAM;UACN6B,GAAG,CAAC3B,GAAG,CAACQ,IAAI,CAACT,KAAK,EAAES,IAAI,CAACV,QAAQ,CAAC;QACnC;MACD;MACA,IAAIU,IAAI,CAACL,QAAQ,EAAE;QAClB,KAAK,MAAMoB,KAAK,IAAIf,IAAI,CAACL,QAAQ,EAAE;UAClCkB,KAAK,CAACG,GAAG,CAACD,KAAK,CAAC;QACjB;MACD;IACD;IACAE,OAAO,CAACzB,GAAG,CAAC0B,QAAQ,CAAC5B,QAAQ,EAAE6B,GAAG,CAAC;EACpC;EACA,OAAOF,OAAO;AACf,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}