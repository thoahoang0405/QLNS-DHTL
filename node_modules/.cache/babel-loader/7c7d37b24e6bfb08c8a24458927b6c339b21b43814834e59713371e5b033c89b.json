{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n\n/**\r\n * Priority queue that processes tasks in natural ordering (lower priority first)\r\n * accoridng to the priority computed by the function passed in the constructor.\r\n *\r\n * FIFO ordering isn't guaranteed for tasks with the same priority.\r\n *\r\n * Worker specific tasks with the same priority as a non-worker specific task\r\n * are always processed first.\r\n */\nclass PriorityQueue {\n  constructor(_computePriority) {\n    _defineProperty(this, '_queue', []);\n    _defineProperty(this, '_sharedQueue', new MinHeap());\n    this._computePriority = _computePriority;\n  }\n  enqueue(task, workerId) {\n    if (workerId == null) {\n      this._enqueue(task, this._sharedQueue);\n    } else {\n      const queue = this._getWorkerQueue(workerId);\n      this._enqueue(task, queue);\n    }\n  }\n  _enqueue(task, queue) {\n    const item = {\n      priority: this._computePriority(task.request[2], ...task.request[3]),\n      task\n    };\n    queue.add(item);\n  }\n  dequeue(workerId) {\n    const workerQueue = this._getWorkerQueue(workerId);\n    const workerTop = workerQueue.peek();\n    const sharedTop = this._sharedQueue.peek(); // use the task from the worker queue if there's no task in the shared queue\n    // or if the priority of the worker queue is smaller or equal to the\n    // priority of the top task in the shared queue. The tasks of the\n    // worker specific queue are preferred because no other worker can pick this\n    // specific task up.\n\n    if (sharedTop == null || workerTop != null && workerTop.priority <= sharedTop.priority) {\n      var _workerQueue$poll$tas, _workerQueue$poll;\n      return (_workerQueue$poll$tas = (_workerQueue$poll = workerQueue.poll()) === null || _workerQueue$poll === void 0 ? void 0 : _workerQueue$poll.task) !== null && _workerQueue$poll$tas !== void 0 ? _workerQueue$poll$tas : null;\n    }\n    return this._sharedQueue.poll().task;\n  }\n  _getWorkerQueue(workerId) {\n    let queue = this._queue[workerId];\n    if (queue == null) {\n      queue = this._queue[workerId] = new MinHeap();\n    }\n    return queue;\n  }\n}\nexports.default = PriorityQueue;\nclass MinHeap {\n  constructor() {\n    _defineProperty(this, '_heap', []);\n  }\n  peek() {\n    var _this$_heap$;\n    return (_this$_heap$ = this._heap[0]) !== null && _this$_heap$ !== void 0 ? _this$_heap$ : null;\n  }\n  add(item) {\n    const nodes = this._heap;\n    nodes.push(item);\n    if (nodes.length === 1) {\n      return;\n    }\n    let currentIndex = nodes.length - 1; // Bubble up the added node as long as the parent is bigger\n\n    while (currentIndex > 0) {\n      const parentIndex = Math.floor((currentIndex + 1) / 2) - 1;\n      const parent = nodes[parentIndex];\n      if (parent.priority <= item.priority) {\n        break;\n      }\n      nodes[currentIndex] = parent;\n      nodes[parentIndex] = item;\n      currentIndex = parentIndex;\n    }\n  }\n  poll() {\n    const nodes = this._heap;\n    const result = nodes[0];\n    const lastElement = nodes.pop(); // heap was empty or removed the last element\n\n    if (result == null || nodes.length === 0) {\n      return result !== null && result !== void 0 ? result : null;\n    }\n    let index = 0;\n    nodes[0] = lastElement !== null && lastElement !== void 0 ? lastElement : null;\n    const element = nodes[0];\n    while (true) {\n      let swapIndex = null;\n      const rightChildIndex = (index + 1) * 2;\n      const leftChildIndex = rightChildIndex - 1;\n      const rightChild = nodes[rightChildIndex];\n      const leftChild = nodes[leftChildIndex]; // if the left child is smaller, swap with the left\n\n      if (leftChild != null && leftChild.priority < element.priority) {\n        swapIndex = leftChildIndex;\n      } // If the right child is smaller or the right child is smaller than the left\n      // then swap with the right child\n\n      if (rightChild != null && rightChild.priority < (swapIndex == null ? element : leftChild).priority) {\n        swapIndex = rightChildIndex;\n      }\n      if (swapIndex == null) {\n        break;\n      }\n      nodes[index] = nodes[swapIndex];\n      nodes[swapIndex] = element;\n      index = swapIndex;\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["require","Object","defineProperty","exports","value","default","_defineProperty","obj","key","enumerable","configurable","writable","PriorityQueue","constructor","_computePriority","MinHeap","enqueue","task","workerId","_enqueue","_sharedQueue","queue","_getWorkerQueue","item","priority","request","add","dequeue","workerQueue","workerTop","peek","sharedTop","_workerQueue$poll$tas","_workerQueue$poll","poll","_queue","_this$_heap$","_heap","nodes","push","length","currentIndex","parentIndex","Math","floor","parent","result","lastElement","pop","index","element","swapIndex","rightChildIndex","leftChildIndex","rightChild","leftChild"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/jest-worker/build/PriorityQueue.js"],"sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, {\r\n      value: value,\r\n      enumerable: true,\r\n      configurable: true,\r\n      writable: true\r\n    });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n/**\r\n * Priority queue that processes tasks in natural ordering (lower priority first)\r\n * accoridng to the priority computed by the function passed in the constructor.\r\n *\r\n * FIFO ordering isn't guaranteed for tasks with the same priority.\r\n *\r\n * Worker specific tasks with the same priority as a non-worker specific task\r\n * are always processed first.\r\n */\r\nclass PriorityQueue {\r\n  constructor(_computePriority) {\r\n    _defineProperty(this, '_queue', []);\r\n\r\n    _defineProperty(this, '_sharedQueue', new MinHeap());\r\n\r\n    this._computePriority = _computePriority;\r\n  }\r\n\r\n  enqueue(task, workerId) {\r\n    if (workerId == null) {\r\n      this._enqueue(task, this._sharedQueue);\r\n    } else {\r\n      const queue = this._getWorkerQueue(workerId);\r\n\r\n      this._enqueue(task, queue);\r\n    }\r\n  }\r\n\r\n  _enqueue(task, queue) {\r\n    const item = {\r\n      priority: this._computePriority(task.request[2], ...task.request[3]),\r\n      task\r\n    };\r\n    queue.add(item);\r\n  }\r\n\r\n  dequeue(workerId) {\r\n    const workerQueue = this._getWorkerQueue(workerId);\r\n\r\n    const workerTop = workerQueue.peek();\r\n\r\n    const sharedTop = this._sharedQueue.peek(); // use the task from the worker queue if there's no task in the shared queue\r\n    // or if the priority of the worker queue is smaller or equal to the\r\n    // priority of the top task in the shared queue. The tasks of the\r\n    // worker specific queue are preferred because no other worker can pick this\r\n    // specific task up.\r\n\r\n    if (\r\n      sharedTop == null ||\r\n      (workerTop != null && workerTop.priority <= sharedTop.priority)\r\n    ) {\r\n      var _workerQueue$poll$tas, _workerQueue$poll;\r\n\r\n      return (_workerQueue$poll$tas =\r\n        (_workerQueue$poll = workerQueue.poll()) === null ||\r\n        _workerQueue$poll === void 0\r\n          ? void 0\r\n          : _workerQueue$poll.task) !== null && _workerQueue$poll$tas !== void 0\r\n        ? _workerQueue$poll$tas\r\n        : null;\r\n    }\r\n\r\n    return this._sharedQueue.poll().task;\r\n  }\r\n\r\n  _getWorkerQueue(workerId) {\r\n    let queue = this._queue[workerId];\r\n\r\n    if (queue == null) {\r\n      queue = this._queue[workerId] = new MinHeap();\r\n    }\r\n\r\n    return queue;\r\n  }\r\n}\r\n\r\nexports.default = PriorityQueue;\r\n\r\nclass MinHeap {\r\n  constructor() {\r\n    _defineProperty(this, '_heap', []);\r\n  }\r\n\r\n  peek() {\r\n    var _this$_heap$;\r\n\r\n    return (_this$_heap$ = this._heap[0]) !== null && _this$_heap$ !== void 0\r\n      ? _this$_heap$\r\n      : null;\r\n  }\r\n\r\n  add(item) {\r\n    const nodes = this._heap;\r\n    nodes.push(item);\r\n\r\n    if (nodes.length === 1) {\r\n      return;\r\n    }\r\n\r\n    let currentIndex = nodes.length - 1; // Bubble up the added node as long as the parent is bigger\r\n\r\n    while (currentIndex > 0) {\r\n      const parentIndex = Math.floor((currentIndex + 1) / 2) - 1;\r\n      const parent = nodes[parentIndex];\r\n\r\n      if (parent.priority <= item.priority) {\r\n        break;\r\n      }\r\n\r\n      nodes[currentIndex] = parent;\r\n      nodes[parentIndex] = item;\r\n      currentIndex = parentIndex;\r\n    }\r\n  }\r\n\r\n  poll() {\r\n    const nodes = this._heap;\r\n    const result = nodes[0];\r\n    const lastElement = nodes.pop(); // heap was empty or removed the last element\r\n\r\n    if (result == null || nodes.length === 0) {\r\n      return result !== null && result !== void 0 ? result : null;\r\n    }\r\n\r\n    let index = 0;\r\n    nodes[0] =\r\n      lastElement !== null && lastElement !== void 0 ? lastElement : null;\r\n    const element = nodes[0];\r\n\r\n    while (true) {\r\n      let swapIndex = null;\r\n      const rightChildIndex = (index + 1) * 2;\r\n      const leftChildIndex = rightChildIndex - 1;\r\n      const rightChild = nodes[rightChildIndex];\r\n      const leftChild = nodes[leftChildIndex]; // if the left child is smaller, swap with the left\r\n\r\n      if (leftChild != null && leftChild.priority < element.priority) {\r\n        swapIndex = leftChildIndex;\r\n      } // If the right child is smaller or the right child is smaller than the left\r\n      // then swap with the right child\r\n\r\n      if (\r\n        rightChild != null &&\r\n        rightChild.priority < (swapIndex == null ? element : leftChild).priority\r\n      ) {\r\n        swapIndex = rightChildIndex;\r\n      }\r\n\r\n      if (swapIndex == null) {\r\n        break;\r\n      }\r\n\r\n      nodes[index] = nodes[swapIndex];\r\n      nodes[swapIndex] = element;\r\n      index = swapIndex;\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}