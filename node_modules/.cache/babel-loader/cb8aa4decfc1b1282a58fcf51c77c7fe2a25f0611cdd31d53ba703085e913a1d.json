{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\nconst getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\nconst Source = require(\"./Source\");\nconst splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\nclass OriginalSource extends Source {\n  constructor(value, name) {\n    super();\n    const isBuffer = Buffer.isBuffer(value);\n    this._value = isBuffer ? undefined : value;\n    this._valueAsBuffer = isBuffer ? value : undefined;\n    this._name = name;\n  }\n  getName() {\n    return this._name;\n  }\n  source() {\n    if (this._value === undefined) {\n      this._value = this._valueAsBuffer.toString(\"utf-8\");\n    }\n    return this._value;\n  }\n  buffer() {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n    return this._valueAsBuffer;\n  }\n  map(options) {\n    return getMap(this, options);\n  }\n  sourceAndMap(options) {\n    return getSourceAndMap(this, options);\n  }\n\n  /**\r\n   * @param {object} options options\r\n   * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\r\n   * @param {function(number, string, string)} onSource called for each source\r\n   * @param {function(number, string)} onName called for each name\r\n   * @returns {void}\r\n   */\n  streamChunks(options, onChunk, onSource, onName) {\n    if (this._value === undefined) {\n      this._value = this._valueAsBuffer.toString(\"utf-8\");\n    }\n    onSource(0, this._name, this._value);\n    const finalSource = !!(options && options.finalSource);\n    if (!options || options.columns !== false) {\n      // With column info we need to read all lines and split them\n      const matches = splitIntoPotentialTokens(this._value);\n      let line = 1;\n      let column = 0;\n      if (matches !== null) {\n        for (const match of matches) {\n          const isEndOfLine = match.endsWith(\"\\n\");\n          if (isEndOfLine && match.length === 1) {\n            if (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n          } else {\n            const chunk = finalSource ? undefined : match;\n            onChunk(chunk, line, column, 0, line, column, -1);\n          }\n          if (isEndOfLine) {\n            line++;\n            column = 0;\n          } else {\n            column += match.length;\n          }\n        }\n      }\n      return {\n        generatedLine: line,\n        generatedColumn: column,\n        source: finalSource ? this._value : undefined\n      };\n    } else if (finalSource) {\n      // Without column info and with final source we only\n      // need meta info to generate mapping\n      const result = getGeneratedSourceInfo(this._value);\n      const {\n        generatedLine,\n        generatedColumn\n      } = result;\n      if (generatedColumn === 0) {\n        for (let line = 1; line < generatedLine; line++) onChunk(undefined, line, 0, 0, line, 0, -1);\n      } else {\n        for (let line = 1; line <= generatedLine; line++) onChunk(undefined, line, 0, 0, line, 0, -1);\n      }\n      return result;\n    } else {\n      // Without column info, but also without final source\n      // we need to split source by lines\n      let line = 1;\n      const matches = splitIntoLines(this._value);\n      let match;\n      for (match of matches) {\n        onChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);\n        line++;\n      }\n      return matches.length === 0 || match.endsWith(\"\\n\") ? {\n        generatedLine: matches.length + 1,\n        generatedColumn: 0,\n        source: finalSource ? this._value : undefined\n      } : {\n        generatedLine: matches.length,\n        generatedColumn: match.length,\n        source: finalSource ? this._value : undefined\n      };\n    }\n  }\n  updateHash(hash) {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n    hash.update(\"OriginalSource\");\n    hash.update(this._valueAsBuffer);\n    hash.update(this._name || \"\");\n  }\n}\nmodule.exports = OriginalSource;","map":{"version":3,"names":["getMap","getSourceAndMap","require","splitIntoLines","getGeneratedSourceInfo","Source","splitIntoPotentialTokens","OriginalSource","constructor","value","name","isBuffer","Buffer","_value","undefined","_valueAsBuffer","_name","getName","source","toString","buffer","from","map","options","sourceAndMap","streamChunks","onChunk","onSource","onName","finalSource","columns","matches","line","column","match","isEndOfLine","endsWith","length","chunk","generatedLine","generatedColumn","result","updateHash","hash","update","module","exports"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/webpack-sources/lib/OriginalSource.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\r\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\r\nconst getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\r\nconst Source = require(\"./Source\");\r\nconst splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\r\n\r\nclass OriginalSource extends Source {\r\n\tconstructor(value, name) {\r\n\t\tsuper();\r\n\t\tconst isBuffer = Buffer.isBuffer(value);\r\n\t\tthis._value = isBuffer ? undefined : value;\r\n\t\tthis._valueAsBuffer = isBuffer ? value : undefined;\r\n\t\tthis._name = name;\r\n\t}\r\n\r\n\tgetName() {\r\n\t\treturn this._name;\r\n\t}\r\n\r\n\tsource() {\r\n\t\tif (this._value === undefined) {\r\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\r\n\t\t}\r\n\t\treturn this._value;\r\n\t}\r\n\r\n\tbuffer() {\r\n\t\tif (this._valueAsBuffer === undefined) {\r\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\r\n\t\t}\r\n\t\treturn this._valueAsBuffer;\r\n\t}\r\n\r\n\tmap(options) {\r\n\t\treturn getMap(this, options);\r\n\t}\r\n\r\n\tsourceAndMap(options) {\r\n\t\treturn getSourceAndMap(this, options);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {object} options options\r\n\t * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\r\n\t * @param {function(number, string, string)} onSource called for each source\r\n\t * @param {function(number, string)} onName called for each name\r\n\t * @returns {void}\r\n\t */\r\n\tstreamChunks(options, onChunk, onSource, onName) {\r\n\t\tif (this._value === undefined) {\r\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\r\n\t\t}\r\n\t\tonSource(0, this._name, this._value);\r\n\t\tconst finalSource = !!(options && options.finalSource);\r\n\t\tif (!options || options.columns !== false) {\r\n\t\t\t// With column info we need to read all lines and split them\r\n\t\t\tconst matches = splitIntoPotentialTokens(this._value);\r\n\t\t\tlet line = 1;\r\n\t\t\tlet column = 0;\r\n\t\t\tif (matches !== null) {\r\n\t\t\t\tfor (const match of matches) {\r\n\t\t\t\t\tconst isEndOfLine = match.endsWith(\"\\n\");\r\n\t\t\t\t\tif (isEndOfLine && match.length === 1) {\r\n\t\t\t\t\t\tif (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconst chunk = finalSource ? undefined : match;\r\n\t\t\t\t\t\tonChunk(chunk, line, column, 0, line, column, -1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isEndOfLine) {\r\n\t\t\t\t\t\tline++;\r\n\t\t\t\t\t\tcolumn = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcolumn += match.length;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tgeneratedLine: line,\r\n\t\t\t\tgeneratedColumn: column,\r\n\t\t\t\tsource: finalSource ? this._value : undefined\r\n\t\t\t};\r\n\t\t} else if (finalSource) {\r\n\t\t\t// Without column info and with final source we only\r\n\t\t\t// need meta info to generate mapping\r\n\t\t\tconst result = getGeneratedSourceInfo(this._value);\r\n\t\t\tconst { generatedLine, generatedColumn } = result;\r\n\t\t\tif (generatedColumn === 0) {\r\n\t\t\t\tfor (let line = 1; line < generatedLine; line++)\r\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\r\n\t\t\t} else {\r\n\t\t\t\tfor (let line = 1; line <= generatedLine; line++)\r\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t} else {\r\n\t\t\t// Without column info, but also without final source\r\n\t\t\t// we need to split source by lines\r\n\t\t\tlet line = 1;\r\n\t\t\tconst matches = splitIntoLines(this._value);\r\n\t\t\tlet match;\r\n\t\t\tfor (match of matches) {\r\n\t\t\t\tonChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);\r\n\t\t\t\tline++;\r\n\t\t\t}\r\n\t\t\treturn matches.length === 0 || match.endsWith(\"\\n\")\r\n\t\t\t\t? {\r\n\t\t\t\t\t\tgeneratedLine: matches.length + 1,\r\n\t\t\t\t\t\tgeneratedColumn: 0,\r\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\r\n\t\t\t\t  }\r\n\t\t\t\t: {\r\n\t\t\t\t\t\tgeneratedLine: matches.length,\r\n\t\t\t\t\t\tgeneratedColumn: match.length,\r\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\r\n\t\t\t\t  };\r\n\t\t}\r\n\t}\r\n\r\n\tupdateHash(hash) {\r\n\t\tif (this._valueAsBuffer === undefined) {\r\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\r\n\t\t}\r\n\t\thash.update(\"OriginalSource\");\r\n\t\thash.update(this._valueAsBuffer);\r\n\t\thash.update(this._name || \"\");\r\n\t}\r\n}\r\n\r\nmodule.exports = OriginalSource;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}