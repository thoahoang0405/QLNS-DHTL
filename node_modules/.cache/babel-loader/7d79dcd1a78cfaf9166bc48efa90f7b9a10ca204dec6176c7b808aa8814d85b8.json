{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst {\n  EventEmitter\n} = require(\"events\");\nconst reducePlan = require(\"./reducePlan\");\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst IS_WIN = require(\"os\").platform() === \"win32\";\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\nconst watcherLimit = +process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\nconst recursiveWatcherLogging = !!process.env.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\nlet isBatch = false;\nlet watcherCount = 0;\n\n/** @type {Map<Watcher, string>} */\nconst pendingWatchers = new Map();\n\n/** @type {Map<string, RecursiveWatcher>} */\nconst recursiveWatchers = new Map();\n\n/** @type {Map<string, DirectWatcher>} */\nconst directWatchers = new Map();\n\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\nconst underlyingWatcher = new Map();\nclass DirectWatcher {\n  constructor(filePath) {\n    this.filePath = filePath;\n    this.watchers = new Set();\n    this.watcher = undefined;\n    try {\n      const watcher = fs.watch(filePath);\n      this.watcher = watcher;\n      watcher.on(\"change\", (type, filename) => {\n        for (const w of this.watchers) {\n          w.emit(\"change\", type, filename);\n        }\n      });\n      watcher.on(\"error\", error => {\n        for (const w of this.watchers) {\n          w.emit(\"error\", error);\n        }\n      });\n    } catch (err) {\n      process.nextTick(() => {\n        for (const w of this.watchers) {\n          w.emit(\"error\", err);\n        }\n      });\n    }\n    watcherCount++;\n  }\n  add(watcher) {\n    underlyingWatcher.set(watcher, this);\n    this.watchers.add(watcher);\n  }\n  remove(watcher) {\n    this.watchers.delete(watcher);\n    if (this.watchers.size === 0) {\n      directWatchers.delete(this.filePath);\n      watcherCount--;\n      if (this.watcher) this.watcher.close();\n    }\n  }\n  getWatchers() {\n    return this.watchers;\n  }\n}\nclass RecursiveWatcher {\n  constructor(rootPath) {\n    this.rootPath = rootPath;\n    /** @type {Map<Watcher, string>} */\n    this.mapWatcherToPath = new Map();\n    /** @type {Map<string, Set<Watcher>>} */\n    this.mapPathToWatchers = new Map();\n    this.watcher = undefined;\n    try {\n      const watcher = fs.watch(rootPath, {\n        recursive: true\n      });\n      this.watcher = watcher;\n      watcher.on(\"change\", (type, filename) => {\n        if (!filename) {\n          if (recursiveWatcherLogging) {\n            process.stderr.write(`[watchpack] dispatch ${type} event in recursive watcher (${this.rootPath}) to all watchers\\n`);\n          }\n          for (const w of this.mapWatcherToPath.keys()) {\n            w.emit(\"change\", type);\n          }\n        } else {\n          const dir = path.dirname(filename);\n          const watchers = this.mapPathToWatchers.get(dir);\n          if (recursiveWatcherLogging) {\n            process.stderr.write(`[watchpack] dispatch ${type} event in recursive watcher (${this.rootPath}) for '${filename}' to ${watchers ? watchers.size : 0} watchers\\n`);\n          }\n          if (watchers === undefined) return;\n          for (const w of watchers) {\n            w.emit(\"change\", type, path.basename(filename));\n          }\n        }\n      });\n      watcher.on(\"error\", error => {\n        for (const w of this.mapWatcherToPath.keys()) {\n          w.emit(\"error\", error);\n        }\n      });\n    } catch (err) {\n      process.nextTick(() => {\n        for (const w of this.mapWatcherToPath.keys()) {\n          w.emit(\"error\", err);\n        }\n      });\n    }\n    watcherCount++;\n    if (recursiveWatcherLogging) {\n      process.stderr.write(`[watchpack] created recursive watcher at ${rootPath}\\n`);\n    }\n  }\n  add(filePath, watcher) {\n    underlyingWatcher.set(watcher, this);\n    const subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n    this.mapWatcherToPath.set(watcher, subpath);\n    const set = this.mapPathToWatchers.get(subpath);\n    if (set === undefined) {\n      const newSet = new Set();\n      newSet.add(watcher);\n      this.mapPathToWatchers.set(subpath, newSet);\n    } else {\n      set.add(watcher);\n    }\n  }\n  remove(watcher) {\n    const subpath = this.mapWatcherToPath.get(watcher);\n    if (!subpath) return;\n    this.mapWatcherToPath.delete(watcher);\n    const set = this.mapPathToWatchers.get(subpath);\n    set.delete(watcher);\n    if (set.size === 0) {\n      this.mapPathToWatchers.delete(subpath);\n    }\n    if (this.mapWatcherToPath.size === 0) {\n      recursiveWatchers.delete(this.rootPath);\n      watcherCount--;\n      if (this.watcher) this.watcher.close();\n      if (recursiveWatcherLogging) {\n        process.stderr.write(`[watchpack] closed recursive watcher at ${this.rootPath}\\n`);\n      }\n    }\n  }\n  getWatchers() {\n    return this.mapWatcherToPath;\n  }\n}\nclass Watcher extends EventEmitter {\n  close() {\n    if (pendingWatchers.has(this)) {\n      pendingWatchers.delete(this);\n      return;\n    }\n    const watcher = underlyingWatcher.get(this);\n    watcher.remove(this);\n    underlyingWatcher.delete(this);\n  }\n}\nconst createDirectWatcher = filePath => {\n  const existing = directWatchers.get(filePath);\n  if (existing !== undefined) return existing;\n  const w = new DirectWatcher(filePath);\n  directWatchers.set(filePath, w);\n  return w;\n};\nconst createRecursiveWatcher = rootPath => {\n  const existing = recursiveWatchers.get(rootPath);\n  if (existing !== undefined) return existing;\n  const w = new RecursiveWatcher(rootPath);\n  recursiveWatchers.set(rootPath, w);\n  return w;\n};\nconst execute = () => {\n  /** @type {Map<string, Watcher[] | Watcher>} */\n  const map = new Map();\n  const addWatcher = (watcher, filePath) => {\n    const entry = map.get(filePath);\n    if (entry === undefined) {\n      map.set(filePath, watcher);\n    } else if (Array.isArray(entry)) {\n      entry.push(watcher);\n    } else {\n      map.set(filePath, [entry, watcher]);\n    }\n  };\n  for (const [watcher, filePath] of pendingWatchers) {\n    addWatcher(watcher, filePath);\n  }\n  pendingWatchers.clear();\n\n  // Fast case when we are not reaching the limit\n  if (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n    // Create watchers for all entries in the map\n    for (const [filePath, entry] of map) {\n      const w = createDirectWatcher(filePath);\n      if (Array.isArray(entry)) {\n        for (const item of entry) w.add(item);\n      } else {\n        w.add(entry);\n      }\n    }\n    return;\n  }\n\n  // Reconsider existing watchers to improving watch plan\n  for (const watcher of recursiveWatchers.values()) {\n    for (const [w, subpath] of watcher.getWatchers()) {\n      addWatcher(w, path.join(watcher.rootPath, subpath));\n    }\n  }\n  for (const watcher of directWatchers.values()) {\n    for (const w of watcher.getWatchers()) {\n      addWatcher(w, watcher.filePath);\n    }\n  }\n\n  // Merge map entries to keep watcher limit\n  // Create a 10% buffer to be able to enter fast case more often\n  const plan = reducePlan(map, watcherLimit * 0.9);\n\n  // Update watchers for all entries in the map\n  for (const [filePath, entry] of plan) {\n    if (entry.size === 1) {\n      for (const [watcher, filePath] of entry) {\n        const w = createDirectWatcher(filePath);\n        const old = underlyingWatcher.get(watcher);\n        if (old === w) continue;\n        w.add(watcher);\n        if (old !== undefined) old.remove(watcher);\n      }\n    } else {\n      const filePaths = new Set(entry.values());\n      if (filePaths.size > 1) {\n        const w = createRecursiveWatcher(filePath);\n        for (const [watcher, watcherPath] of entry) {\n          const old = underlyingWatcher.get(watcher);\n          if (old === w) continue;\n          w.add(watcherPath, watcher);\n          if (old !== undefined) old.remove(watcher);\n        }\n      } else {\n        for (const filePath of filePaths) {\n          const w = createDirectWatcher(filePath);\n          for (const watcher of entry.keys()) {\n            const old = underlyingWatcher.get(watcher);\n            if (old === w) continue;\n            w.add(watcher);\n            if (old !== undefined) old.remove(watcher);\n          }\n        }\n      }\n    }\n  }\n};\nexports.watch = filePath => {\n  const watcher = new Watcher();\n  // Find an existing watcher\n  const directWatcher = directWatchers.get(filePath);\n  if (directWatcher !== undefined) {\n    directWatcher.add(watcher);\n    return watcher;\n  }\n  let current = filePath;\n  for (;;) {\n    const recursiveWatcher = recursiveWatchers.get(current);\n    if (recursiveWatcher !== undefined) {\n      recursiveWatcher.add(filePath, watcher);\n      return watcher;\n    }\n    const parent = path.dirname(current);\n    if (parent === current) break;\n    current = parent;\n  }\n  // Queue up watcher for creation\n  pendingWatchers.set(watcher, filePath);\n  if (!isBatch) execute();\n  return watcher;\n};\nexports.batch = fn => {\n  isBatch = true;\n  try {\n    fn();\n  } finally {\n    isBatch = false;\n    execute();\n  }\n};\nexports.getNumberOfWatchers = () => {\n  return watcherCount;\n};","map":{"version":3,"names":["require","fs","path","EventEmitter","reducePlan","IS_OSX","platform","IS_WIN","SUPPORTS_RECURSIVE_WATCHING","watcherLimit","process","env","WATCHPACK_WATCHER_LIMIT","recursiveWatcherLogging","WATCHPACK_RECURSIVE_WATCHER_LOGGING","isBatch","watcherCount","pendingWatchers","Map","recursiveWatchers","directWatchers","underlyingWatcher","DirectWatcher","constructor","filePath","watchers","Set","watcher","undefined","watch","on","type","filename","w","emit","error","err","nextTick","add","set","remove","delete","size","close","getWatchers","RecursiveWatcher","rootPath","mapWatcherToPath","mapPathToWatchers","recursive","stderr","write","keys","dir","dirname","get","basename","subpath","slice","length","newSet","Watcher","has","createDirectWatcher","existing","createRecursiveWatcher","execute","map","addWatcher","entry","Array","isArray","push","clear","item","values","join","plan","old","filePaths","watcherPath","exports","directWatcher","current","recursiveWatcher","parent","batch","fn","getNumberOfWatchers"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/watchpack/lib/watchEventSource.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst { EventEmitter } = require(\"events\");\r\nconst reducePlan = require(\"./reducePlan\");\r\n\r\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\r\nconst IS_WIN = require(\"os\").platform() === \"win32\";\r\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\r\n\r\nconst watcherLimit =\r\n\t+process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\r\n\r\nconst recursiveWatcherLogging = !!process.env\r\n\t.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\r\n\r\nlet isBatch = false;\r\nlet watcherCount = 0;\r\n\r\n/** @type {Map<Watcher, string>} */\r\nconst pendingWatchers = new Map();\r\n\r\n/** @type {Map<string, RecursiveWatcher>} */\r\nconst recursiveWatchers = new Map();\r\n\r\n/** @type {Map<string, DirectWatcher>} */\r\nconst directWatchers = new Map();\r\n\r\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\r\nconst underlyingWatcher = new Map();\r\n\r\nclass DirectWatcher {\r\n\tconstructor(filePath) {\r\n\t\tthis.filePath = filePath;\r\n\t\tthis.watchers = new Set();\r\n\t\tthis.watcher = undefined;\r\n\t\ttry {\r\n\t\t\tconst watcher = fs.watch(filePath);\r\n\t\t\tthis.watcher = watcher;\r\n\t\t\twatcher.on(\"change\", (type, filename) => {\r\n\t\t\t\tfor (const w of this.watchers) {\r\n\t\t\t\t\tw.emit(\"change\", type, filename);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\twatcher.on(\"error\", error => {\r\n\t\t\t\tfor (const w of this.watchers) {\r\n\t\t\t\t\tw.emit(\"error\", error);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} catch (err) {\r\n\t\t\tprocess.nextTick(() => {\r\n\t\t\t\tfor (const w of this.watchers) {\r\n\t\t\t\t\tw.emit(\"error\", err);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\twatcherCount++;\r\n\t}\r\n\r\n\tadd(watcher) {\r\n\t\tunderlyingWatcher.set(watcher, this);\r\n\t\tthis.watchers.add(watcher);\r\n\t}\r\n\r\n\tremove(watcher) {\r\n\t\tthis.watchers.delete(watcher);\r\n\t\tif (this.watchers.size === 0) {\r\n\t\t\tdirectWatchers.delete(this.filePath);\r\n\t\t\twatcherCount--;\r\n\t\t\tif (this.watcher) this.watcher.close();\r\n\t\t}\r\n\t}\r\n\r\n\tgetWatchers() {\r\n\t\treturn this.watchers;\r\n\t}\r\n}\r\n\r\nclass RecursiveWatcher {\r\n\tconstructor(rootPath) {\r\n\t\tthis.rootPath = rootPath;\r\n\t\t/** @type {Map<Watcher, string>} */\r\n\t\tthis.mapWatcherToPath = new Map();\r\n\t\t/** @type {Map<string, Set<Watcher>>} */\r\n\t\tthis.mapPathToWatchers = new Map();\r\n\t\tthis.watcher = undefined;\r\n\t\ttry {\r\n\t\t\tconst watcher = fs.watch(rootPath, {\r\n\t\t\t\trecursive: true\r\n\t\t\t});\r\n\t\t\tthis.watcher = watcher;\r\n\t\t\twatcher.on(\"change\", (type, filename) => {\r\n\t\t\t\tif (!filename) {\r\n\t\t\t\t\tif (recursiveWatcherLogging) {\r\n\t\t\t\t\t\tprocess.stderr.write(\r\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\r\n\t\t\t\t\t\t\t\tthis.rootPath\r\n\t\t\t\t\t\t\t}) to all watchers\\n`\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\r\n\t\t\t\t\t\tw.emit(\"change\", type);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst dir = path.dirname(filename);\r\n\t\t\t\t\tconst watchers = this.mapPathToWatchers.get(dir);\r\n\t\t\t\t\tif (recursiveWatcherLogging) {\r\n\t\t\t\t\t\tprocess.stderr.write(\r\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\r\n\t\t\t\t\t\t\t\tthis.rootPath\r\n\t\t\t\t\t\t\t}) for '${filename}' to ${\r\n\t\t\t\t\t\t\t\twatchers ? watchers.size : 0\r\n\t\t\t\t\t\t\t} watchers\\n`\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (watchers === undefined) return;\r\n\t\t\t\t\tfor (const w of watchers) {\r\n\t\t\t\t\t\tw.emit(\"change\", type, path.basename(filename));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\twatcher.on(\"error\", error => {\r\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\r\n\t\t\t\t\tw.emit(\"error\", error);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} catch (err) {\r\n\t\t\tprocess.nextTick(() => {\r\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\r\n\t\t\t\t\tw.emit(\"error\", err);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\twatcherCount++;\r\n\t\tif (recursiveWatcherLogging) {\r\n\t\t\tprocess.stderr.write(\r\n\t\t\t\t`[watchpack] created recursive watcher at ${rootPath}\\n`\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tadd(filePath, watcher) {\r\n\t\tunderlyingWatcher.set(watcher, this);\r\n\t\tconst subpath = filePath.slice(this.rootPath.length + 1) || \".\";\r\n\t\tthis.mapWatcherToPath.set(watcher, subpath);\r\n\t\tconst set = this.mapPathToWatchers.get(subpath);\r\n\t\tif (set === undefined) {\r\n\t\t\tconst newSet = new Set();\r\n\t\t\tnewSet.add(watcher);\r\n\t\t\tthis.mapPathToWatchers.set(subpath, newSet);\r\n\t\t} else {\r\n\t\t\tset.add(watcher);\r\n\t\t}\r\n\t}\r\n\r\n\tremove(watcher) {\r\n\t\tconst subpath = this.mapWatcherToPath.get(watcher);\r\n\t\tif (!subpath) return;\r\n\t\tthis.mapWatcherToPath.delete(watcher);\r\n\t\tconst set = this.mapPathToWatchers.get(subpath);\r\n\t\tset.delete(watcher);\r\n\t\tif (set.size === 0) {\r\n\t\t\tthis.mapPathToWatchers.delete(subpath);\r\n\t\t}\r\n\t\tif (this.mapWatcherToPath.size === 0) {\r\n\t\t\trecursiveWatchers.delete(this.rootPath);\r\n\t\t\twatcherCount--;\r\n\t\t\tif (this.watcher) this.watcher.close();\r\n\t\t\tif (recursiveWatcherLogging) {\r\n\t\t\t\tprocess.stderr.write(\r\n\t\t\t\t\t`[watchpack] closed recursive watcher at ${this.rootPath}\\n`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgetWatchers() {\r\n\t\treturn this.mapWatcherToPath;\r\n\t}\r\n}\r\n\r\nclass Watcher extends EventEmitter {\r\n\tclose() {\r\n\t\tif (pendingWatchers.has(this)) {\r\n\t\t\tpendingWatchers.delete(this);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst watcher = underlyingWatcher.get(this);\r\n\t\twatcher.remove(this);\r\n\t\tunderlyingWatcher.delete(this);\r\n\t}\r\n}\r\n\r\nconst createDirectWatcher = filePath => {\r\n\tconst existing = directWatchers.get(filePath);\r\n\tif (existing !== undefined) return existing;\r\n\tconst w = new DirectWatcher(filePath);\r\n\tdirectWatchers.set(filePath, w);\r\n\treturn w;\r\n};\r\n\r\nconst createRecursiveWatcher = rootPath => {\r\n\tconst existing = recursiveWatchers.get(rootPath);\r\n\tif (existing !== undefined) return existing;\r\n\tconst w = new RecursiveWatcher(rootPath);\r\n\trecursiveWatchers.set(rootPath, w);\r\n\treturn w;\r\n};\r\n\r\nconst execute = () => {\r\n\t/** @type {Map<string, Watcher[] | Watcher>} */\r\n\tconst map = new Map();\r\n\tconst addWatcher = (watcher, filePath) => {\r\n\t\tconst entry = map.get(filePath);\r\n\t\tif (entry === undefined) {\r\n\t\t\tmap.set(filePath, watcher);\r\n\t\t} else if (Array.isArray(entry)) {\r\n\t\t\tentry.push(watcher);\r\n\t\t} else {\r\n\t\t\tmap.set(filePath, [entry, watcher]);\r\n\t\t}\r\n\t};\r\n\tfor (const [watcher, filePath] of pendingWatchers) {\r\n\t\taddWatcher(watcher, filePath);\r\n\t}\r\n\tpendingWatchers.clear();\r\n\r\n\t// Fast case when we are not reaching the limit\r\n\tif (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\r\n\t\t// Create watchers for all entries in the map\r\n\t\tfor (const [filePath, entry] of map) {\r\n\t\t\tconst w = createDirectWatcher(filePath);\r\n\t\t\tif (Array.isArray(entry)) {\r\n\t\t\t\tfor (const item of entry) w.add(item);\r\n\t\t\t} else {\r\n\t\t\t\tw.add(entry);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Reconsider existing watchers to improving watch plan\r\n\tfor (const watcher of recursiveWatchers.values()) {\r\n\t\tfor (const [w, subpath] of watcher.getWatchers()) {\r\n\t\t\taddWatcher(w, path.join(watcher.rootPath, subpath));\r\n\t\t}\r\n\t}\r\n\tfor (const watcher of directWatchers.values()) {\r\n\t\tfor (const w of watcher.getWatchers()) {\r\n\t\t\taddWatcher(w, watcher.filePath);\r\n\t\t}\r\n\t}\r\n\r\n\t// Merge map entries to keep watcher limit\r\n\t// Create a 10% buffer to be able to enter fast case more often\r\n\tconst plan = reducePlan(map, watcherLimit * 0.9);\r\n\r\n\t// Update watchers for all entries in the map\r\n\tfor (const [filePath, entry] of plan) {\r\n\t\tif (entry.size === 1) {\r\n\t\t\tfor (const [watcher, filePath] of entry) {\r\n\t\t\t\tconst w = createDirectWatcher(filePath);\r\n\t\t\t\tconst old = underlyingWatcher.get(watcher);\r\n\t\t\t\tif (old === w) continue;\r\n\t\t\t\tw.add(watcher);\r\n\t\t\t\tif (old !== undefined) old.remove(watcher);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconst filePaths = new Set(entry.values());\r\n\t\t\tif (filePaths.size > 1) {\r\n\t\t\t\tconst w = createRecursiveWatcher(filePath);\r\n\t\t\t\tfor (const [watcher, watcherPath] of entry) {\r\n\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\r\n\t\t\t\t\tif (old === w) continue;\r\n\t\t\t\t\tw.add(watcherPath, watcher);\r\n\t\t\t\t\tif (old !== undefined) old.remove(watcher);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (const filePath of filePaths) {\r\n\t\t\t\t\tconst w = createDirectWatcher(filePath);\r\n\t\t\t\t\tfor (const watcher of entry.keys()) {\r\n\t\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\r\n\t\t\t\t\t\tif (old === w) continue;\r\n\t\t\t\t\t\tw.add(watcher);\r\n\t\t\t\t\t\tif (old !== undefined) old.remove(watcher);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nexports.watch = filePath => {\r\n\tconst watcher = new Watcher();\r\n\t// Find an existing watcher\r\n\tconst directWatcher = directWatchers.get(filePath);\r\n\tif (directWatcher !== undefined) {\r\n\t\tdirectWatcher.add(watcher);\r\n\t\treturn watcher;\r\n\t}\r\n\tlet current = filePath;\r\n\tfor (;;) {\r\n\t\tconst recursiveWatcher = recursiveWatchers.get(current);\r\n\t\tif (recursiveWatcher !== undefined) {\r\n\t\t\trecursiveWatcher.add(filePath, watcher);\r\n\t\t\treturn watcher;\r\n\t\t}\r\n\t\tconst parent = path.dirname(current);\r\n\t\tif (parent === current) break;\r\n\t\tcurrent = parent;\r\n\t}\r\n\t// Queue up watcher for creation\r\n\tpendingWatchers.set(watcher, filePath);\r\n\tif (!isBatch) execute();\r\n\treturn watcher;\r\n};\r\n\r\nexports.batch = fn => {\r\n\tisBatch = true;\r\n\ttry {\r\n\t\tfn();\r\n\t} finally {\r\n\t\tisBatch = false;\r\n\t\texecute();\r\n\t}\r\n};\r\n\r\nexports.getNumberOfWatchers = () => {\r\n\treturn watcherCount;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}