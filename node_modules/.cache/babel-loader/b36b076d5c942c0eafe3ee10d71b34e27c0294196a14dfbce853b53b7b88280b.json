{"ast":null,"code":"\"use strict\";\n\n/** @typedef {import(\"@jridgewell/trace-mapping\").SourceMapInput} SourceMapInput */\n\n/** @typedef {import(\"terser\").FormatOptions} TerserFormatOptions */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserOptions */\n\n/** @typedef {import(\"terser\").CompressOptions} TerserCompressOptions */\n\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\n\n/** @typedef {import(\"./index.js\").Input} Input */\n\n/** @typedef {import(\"./index.js\").MinimizedResult} MinimizedResult */\n\n/** @typedef {import(\"./index.js\").PredefinedOptions} PredefinedOptions */\n\n/** @typedef {import(\"./index.js\").CustomOptions} CustomOptions */\n\n/**\r\n * @typedef {Array<string>} ExtractedComments\r\n */\nrequire(\"core-js/modules/es.array.push.js\");\nconst notSettled = Symbol(`not-settled`);\n/**\r\n * @template T\r\n * @typedef {() => Promise<T>} Task\r\n */\n\n/**\r\n * Run tasks with limited concurency.\r\n * @template T\r\n * @param {number} limit - Limit of tasks that run at once.\r\n * @param {Task<T>[]} tasks - List of tasks to run.\r\n * @returns {Promise<T[]>} A promise that fulfills to an array of the results\r\n */\n\nfunction throttleAll(limit, tasks) {\n  if (!Number.isInteger(limit) || limit < 1) {\n    throw new TypeError(`Expected \\`limit\\` to be a finite number > 0, got \\`${limit}\\` (${typeof limit})`);\n  }\n  if (!Array.isArray(tasks) || !tasks.every(task => typeof task === `function`)) {\n    throw new TypeError(`Expected \\`tasks\\` to be a list of functions returning a promise`);\n  }\n  return new Promise((resolve, reject) => {\n    const result = Array(tasks.length).fill(notSettled);\n    const entries = tasks.entries();\n    const next = () => {\n      const {\n        done,\n        value\n      } = entries.next();\n      if (done) {\n        const isLast = !result.includes(notSettled);\n        if (isLast) resolve( /** @type{T[]} **/\n        result);\n        return;\n      }\n      const [index, task] = value;\n      /**\r\n       * @param {T} x\r\n       */\n\n      const onFulfilled = x => {\n        result[index] = x;\n        next();\n      };\n      task().then(onFulfilled, reject);\n    };\n    Array(limit).fill(0).forEach(next);\n  });\n}\n/* istanbul ignore next */\n\n/**\r\n * @param {Input} input\r\n * @param {SourceMapInput | undefined} sourceMap\r\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\r\n * @param {ExtractCommentsOptions | undefined} extractComments\r\n * @return {Promise<MinimizedResult>}\r\n */\n\nasync function terserMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\r\n   * @param {any} value\r\n   * @returns {boolean}\r\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n  /**\r\n   * @param {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })} terserOptions\r\n   * @param {ExtractedComments} extractedComments\r\n   * @returns {ExtractCommentsFunction}\r\n   */\n\n  const buildComments = (terserOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    let comments;\n    if (terserOptions.format) {\n      ({\n        comments\n      } = terserOptions.format);\n    } else if (terserOptions.output) {\n      ({\n        comments\n      } = terserOptions.output);\n    }\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    } // Ensure that both conditions are functions\n\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n\n      let regex;\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n        case \"function\":\n          break;\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n            break;\n          }\n          if (condition[key] === \"some\") {\n            condition[key] = /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n            break;\n          }\n          regexStr = /** @type {string} */\n          condition[key];\n          condition[key] = /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp( /** @type {string} */\n          regexStr).test(comment.value);\n          break;\n        default:\n          regex = /** @type {RegExp} */\n          condition[key];\n          condition[key] = /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => /** @type {RegExp} */\n          regex.test(comment.value);\n      }\n    }); // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n\n    return (astNode, comment) => {\n      if ( /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n      return (/** @type {{ preserve: ExtractCommentsFunction }} */\n        condition.preserve(astNode, comment)\n      );\n    };\n  };\n  /**\r\n   * @param {PredefinedOptions & TerserOptions} [terserOptions={}]\r\n   * @returns {TerserOptions & { sourceMap: undefined } & { compress: TerserCompressOptions } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })}\r\n   */\n\n  const buildTerserOptions = (terserOptions = {}) => {\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return {\n      ...terserOptions,\n      compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress ? {} : false : {\n        ...terserOptions.compress\n      },\n      // ecma: terserOptions.ecma,\n      // ie8: terserOptions.ie8,\n      // keep_classnames: terserOptions.keep_classnames,\n      // keep_fnames: terserOptions.keep_fnames,\n      mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : {\n        ...terserOptions.mangle\n      },\n      // module: terserOptions.module,\n      // nameCache: { ...terserOptions.toplevel },\n      // the `output` option is deprecated\n      ...(terserOptions.format ? {\n        format: {\n          beautify: false,\n          ...terserOptions.format\n        }\n      } : {\n        output: {\n          beautify: false,\n          ...terserOptions.output\n        }\n      }),\n      parse: {\n        ...terserOptions.parse\n      },\n      // safari10: terserOptions.safari10,\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined // toplevel: terserOptions.toplevel\n    };\n  }; // eslint-disable-next-line global-require\n\n  const {\n    minify\n  } = require(\"terser\"); // Copy `terser` options\n\n  const terserOptions = buildTerserOptions(minimizerOptions); // Let terser generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n  /** @type {ExtractedComments} */\n\n  const extractedComments = [];\n  if (terserOptions.output) {\n    terserOptions.output.comments = buildComments(terserOptions, extractedComments);\n  } else if (terserOptions.format) {\n    terserOptions.format.comments = buildComments(terserOptions, extractedComments);\n  }\n  if (terserOptions.compress) {\n    // More optimizations\n    if (typeof terserOptions.compress.ecma === \"undefined\") {\n      terserOptions.compress.ecma = terserOptions.ecma;\n    } // https://github.com/webpack/webpack/issues/16135\n\n    if (terserOptions.ecma === 5 && typeof terserOptions.compress.arrows === \"undefined\") {\n      terserOptions.compress.arrows = false;\n    }\n  }\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, terserOptions);\n  return {\n    code: /** @type {string} **/\n    result.code,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    map: result.map ? /** @type {SourceMapInput} **/\n    result.map : undefined,\n    extractedComments\n  };\n}\n/**\r\n * @returns {string | undefined}\r\n */\n\nterserMinify.getMinimizerVersion = () => {\n  let packageJson;\n  try {\n    // eslint-disable-next-line global-require\n    packageJson = require(\"terser/package.json\");\n  } catch (error) {// Ignore\n  }\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\r\n * @param {Input} input\r\n * @param {SourceMapInput | undefined} sourceMap\r\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\r\n * @param {ExtractCommentsOptions | undefined} extractComments\r\n * @return {Promise<MinimizedResult>}\r\n */\n\nasync function uglifyJsMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\r\n   * @param {any} value\r\n   * @returns {boolean}\r\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n  /**\r\n   * @param {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}} uglifyJsOptions\r\n   * @param {ExtractedComments} extractedComments\r\n   * @returns {ExtractCommentsFunction}\r\n   */\n\n  const buildComments = (uglifyJsOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    const {\n      comments\n    } = uglifyJsOptions.output;\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    } // Ensure that both conditions are functions\n\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n\n      let regex;\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n        case \"function\":\n          break;\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n            break;\n          }\n          if (condition[key] === \"some\") {\n            condition[key] = /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n            break;\n          }\n          regexStr = /** @type {string} */\n          condition[key];\n          condition[key] = /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp( /** @type {string} */\n          regexStr).test(comment.value);\n          break;\n        default:\n          regex = /** @type {RegExp} */\n          condition[key];\n          condition[key] = /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => /** @type {RegExp} */\n          regex.test(comment.value);\n      }\n    }); // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n\n    return (astNode, comment) => {\n      if ( /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n      return (/** @type {{ preserve: ExtractCommentsFunction }} */\n        condition.preserve(astNode, comment)\n      );\n    };\n  };\n  /**\r\n   * @param {PredefinedOptions & import(\"uglify-js\").MinifyOptions} [uglifyJsOptions={}]\r\n   * @returns {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}}\r\n   */\n\n  const buildUglifyJsOptions = (uglifyJsOptions = {}) => {\n    // eslint-disable-next-line no-param-reassign\n    delete minimizerOptions.ecma; // eslint-disable-next-line no-param-reassign\n\n    delete minimizerOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n    return {\n      ...uglifyJsOptions,\n      // warnings: uglifyJsOptions.warnings,\n      parse: {\n        ...uglifyJsOptions.parse\n      },\n      compress: typeof uglifyJsOptions.compress === \"boolean\" ? uglifyJsOptions.compress : {\n        ...uglifyJsOptions.compress\n      },\n      mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === \"boolean\" ? uglifyJsOptions.mangle : {\n        ...uglifyJsOptions.mangle\n      },\n      output: {\n        beautify: false,\n        ...uglifyJsOptions.output\n      },\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined // toplevel: uglifyJsOptions.toplevel\n      // nameCache: { ...uglifyJsOptions.toplevel },\n      // ie8: uglifyJsOptions.ie8,\n      // keep_fnames: uglifyJsOptions.keep_fnames,\n    };\n  }; // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n\n  const {\n    minify\n  } = require(\"uglify-js\"); // Copy `uglify-js` options\n\n  const uglifyJsOptions = buildUglifyJsOptions(minimizerOptions); // Let terser generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    uglifyJsOptions.sourceMap = true;\n  }\n  /** @type {ExtractedComments} */\n\n  const extractedComments = []; // @ts-ignore\n\n  uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, uglifyJsOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    errors: result.error ? [result.error] : [],\n    warnings: result.warnings || [],\n    extractedComments\n  };\n}\n/**\r\n * @returns {string | undefined}\r\n */\n\nuglifyJsMinify.getMinimizerVersion = () => {\n  let packageJson;\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"uglify-js/package.json\");\n  } catch (error) {// Ignore\n  }\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\r\n * @param {Input} input\r\n * @param {SourceMapInput | undefined} sourceMap\r\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\r\n * @return {Promise<MinimizedResult>}\r\n */\n\nasync function swcMinify(input, sourceMap, minimizerOptions) {\n  /**\r\n   * @param {PredefinedOptions & import(\"@swc/core\").JsMinifyOptions} [swcOptions={}]\r\n   * @returns {import(\"@swc/core\").JsMinifyOptions & { sourceMap: undefined } & { compress: import(\"@swc/core\").TerserCompressOptions }}\r\n   */\n  const buildSwcOptions = (swcOptions = {}) => {\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return {\n      ...swcOptions,\n      compress: typeof swcOptions.compress === \"boolean\" ? swcOptions.compress ? {} : false : {\n        ...swcOptions.compress\n      },\n      mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === \"boolean\" ? swcOptions.mangle : {\n        ...swcOptions.mangle\n      },\n      // ecma: swcOptions.ecma,\n      // keep_classnames: swcOptions.keep_classnames,\n      // keep_fnames: swcOptions.keep_fnames,\n      // module: swcOptions.module,\n      // safari10: swcOptions.safari10,\n      // toplevel: swcOptions.toplevel\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined\n    };\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n  const swc = require(\"@swc/core\"); // Copy `swc` options\n\n  const swcOptions = buildSwcOptions(minimizerOptions); // Let `swc` generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    swcOptions.sourceMap = true;\n  }\n  if (swcOptions.compress) {\n    // More optimizations\n    if (typeof swcOptions.compress.ecma === \"undefined\") {\n      swcOptions.compress.ecma = swcOptions.ecma;\n    } // https://github.com/webpack/webpack/issues/16135\n\n    if (swcOptions.ecma === 5 && typeof swcOptions.compress.arrows === \"undefined\") {\n      swcOptions.compress.arrows = false;\n    }\n  }\n  const [[filename, code]] = Object.entries(input);\n  const result = await swc.minify(code, swcOptions);\n  let map;\n  if (result.map) {\n    map = JSON.parse(result.map); // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`\n\n    map.sources = [filename];\n    delete map.sourcesContent;\n  }\n  return {\n    code: result.code,\n    map\n  };\n}\n/**\r\n * @returns {string | undefined}\r\n */\n\nswcMinify.getMinimizerVersion = () => {\n  let packageJson;\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"@swc/core/package.json\");\n  } catch (error) {// Ignore\n  }\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\r\n * @param {Input} input\r\n * @param {SourceMapInput | undefined} sourceMap\r\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\r\n * @return {Promise<MinimizedResult>}\r\n */\n\nasync function esbuildMinify(input, sourceMap, minimizerOptions) {\n  /**\r\n   * @param {PredefinedOptions & import(\"esbuild\").TransformOptions} [esbuildOptions={}]\r\n   * @returns {import(\"esbuild\").TransformOptions}\r\n   */\n  const buildEsbuildOptions = (esbuildOptions = {}) => {\n    // eslint-disable-next-line no-param-reassign\n    delete esbuildOptions.ecma;\n    if (esbuildOptions.module) {\n      // eslint-disable-next-line no-param-reassign\n      esbuildOptions.format = \"esm\";\n    } // eslint-disable-next-line no-param-reassign\n\n    delete esbuildOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n    return {\n      minify: true,\n      legalComments: \"inline\",\n      ...esbuildOptions,\n      sourcemap: false\n    };\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n  const esbuild = require(\"esbuild\"); // Copy `esbuild` options\n\n  const esbuildOptions = buildEsbuildOptions(minimizerOptions); // Let `esbuild` generate a SourceMap\n\n  if (sourceMap) {\n    esbuildOptions.sourcemap = true;\n    esbuildOptions.sourcesContent = false;\n  }\n  const [[filename, code]] = Object.entries(input);\n  esbuildOptions.sourcefile = filename;\n  const result = await esbuild.transform(code, esbuildOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    warnings: result.warnings.length > 0 ? result.warnings.map(item => {\n      return {\n        name: \"Warning\",\n        source: item.location && item.location.file,\n        line: item.location && item.location.line,\n        column: item.location && item.location.column,\n        plugin: item.pluginName,\n        message: `${item.text}${item.detail ? `\\nDetails:\\n${item.detail}` : \"\"}${item.notes.length > 0 ? `\\n\\nNotes:\\n${item.notes.map(note => `${note.location ? `[${note.location.file}:${note.location.line}:${note.location.column}] ` : \"\"}${note.text}${note.location ? `\\nSuggestion: ${note.location.suggestion}` : \"\"}${note.location ? `\\nLine text:\\n${note.location.lineText}\\n` : \"\"}`).join(\"\\n\")}` : \"\"}`\n      };\n    }) : []\n  };\n}\n/**\r\n * @returns {string | undefined}\r\n */\n\nesbuildMinify.getMinimizerVersion = () => {\n  let packageJson;\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"esbuild/package.json\");\n  } catch (error) {// Ignore\n  }\n  return packageJson && packageJson.version;\n};\nmodule.exports = {\n  throttleAll,\n  terserMinify,\n  uglifyJsMinify,\n  swcMinify,\n  esbuildMinify\n};","map":{"version":3,"names":["require","notSettled","Symbol","throttleAll","limit","tasks","Number","isInteger","TypeError","Array","isArray","every","task","Promise","resolve","reject","result","length","fill","entries","next","done","value","isLast","includes","index","onFulfilled","x","then","forEach","terserMinify","input","sourceMap","minimizerOptions","extractComments","isObject","type","buildComments","terserOptions","extractedComments","condition","comments","format","output","preserve","extract","RegExp","key","regexStr","regex","astNode","comment","test","commentText","push","buildTerserOptions","compress","mangle","beautify","parse","undefined","minify","asObject","ecma","arrows","filename","code","Object","map","getMinimizerVersion","packageJson","error","version","uglifyJsMinify","uglifyJsOptions","buildUglifyJsOptions","module","JSON","errors","warnings","swcMinify","buildSwcOptions","swcOptions","swc","sources","sourcesContent","esbuildMinify","buildEsbuildOptions","esbuildOptions","legalComments","sourcemap","esbuild","sourcefile","transform","item","name","source","location","file","line","column","plugin","pluginName","message","text","detail","notes","note","suggestion","lineText","join","exports"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/terser-webpack-plugin/dist/utils.js"],"sourcesContent":["\"use strict\";\r\n\r\n/** @typedef {import(\"@jridgewell/trace-mapping\").SourceMapInput} SourceMapInput */\r\n\r\n/** @typedef {import(\"terser\").FormatOptions} TerserFormatOptions */\r\n\r\n/** @typedef {import(\"terser\").MinifyOptions} TerserOptions */\r\n\r\n/** @typedef {import(\"terser\").CompressOptions} TerserCompressOptions */\r\n\r\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\r\n\r\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\r\n\r\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\r\n\r\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\r\n\r\n/** @typedef {import(\"./index.js\").Input} Input */\r\n\r\n/** @typedef {import(\"./index.js\").MinimizedResult} MinimizedResult */\r\n\r\n/** @typedef {import(\"./index.js\").PredefinedOptions} PredefinedOptions */\r\n\r\n/** @typedef {import(\"./index.js\").CustomOptions} CustomOptions */\r\n\r\n/**\r\n * @typedef {Array<string>} ExtractedComments\r\n */\r\nconst notSettled = Symbol(`not-settled`);\r\n/**\r\n * @template T\r\n * @typedef {() => Promise<T>} Task\r\n */\r\n\r\n/**\r\n * Run tasks with limited concurency.\r\n * @template T\r\n * @param {number} limit - Limit of tasks that run at once.\r\n * @param {Task<T>[]} tasks - List of tasks to run.\r\n * @returns {Promise<T[]>} A promise that fulfills to an array of the results\r\n */\r\n\r\nfunction throttleAll(limit, tasks) {\r\n  if (!Number.isInteger(limit) || limit < 1) {\r\n    throw new TypeError(`Expected \\`limit\\` to be a finite number > 0, got \\`${limit}\\` (${typeof limit})`);\r\n  }\r\n\r\n  if (!Array.isArray(tasks) || !tasks.every(task => typeof task === `function`)) {\r\n    throw new TypeError(`Expected \\`tasks\\` to be a list of functions returning a promise`);\r\n  }\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const result = Array(tasks.length).fill(notSettled);\r\n    const entries = tasks.entries();\r\n\r\n    const next = () => {\r\n      const {\r\n        done,\r\n        value\r\n      } = entries.next();\r\n\r\n      if (done) {\r\n        const isLast = !result.includes(notSettled);\r\n        if (isLast) resolve(\r\n        /** @type{T[]} **/\r\n        result);\r\n        return;\r\n      }\r\n\r\n      const [index, task] = value;\r\n      /**\r\n       * @param {T} x\r\n       */\r\n\r\n      const onFulfilled = x => {\r\n        result[index] = x;\r\n        next();\r\n      };\r\n\r\n      task().then(onFulfilled, reject);\r\n    };\r\n\r\n    Array(limit).fill(0).forEach(next);\r\n  });\r\n}\r\n/* istanbul ignore next */\r\n\r\n/**\r\n * @param {Input} input\r\n * @param {SourceMapInput | undefined} sourceMap\r\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\r\n * @param {ExtractCommentsOptions | undefined} extractComments\r\n * @return {Promise<MinimizedResult>}\r\n */\r\n\r\n\r\nasync function terserMinify(input, sourceMap, minimizerOptions, extractComments) {\r\n  /**\r\n   * @param {any} value\r\n   * @returns {boolean}\r\n   */\r\n  const isObject = value => {\r\n    const type = typeof value;\r\n    return value != null && (type === \"object\" || type === \"function\");\r\n  };\r\n  /**\r\n   * @param {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })} terserOptions\r\n   * @param {ExtractedComments} extractedComments\r\n   * @returns {ExtractCommentsFunction}\r\n   */\r\n\r\n\r\n  const buildComments = (terserOptions, extractedComments) => {\r\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\r\n    const condition = {};\r\n    let comments;\r\n\r\n    if (terserOptions.format) {\r\n      ({\r\n        comments\r\n      } = terserOptions.format);\r\n    } else if (terserOptions.output) {\r\n      ({\r\n        comments\r\n      } = terserOptions.output);\r\n    }\r\n\r\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\r\n\r\n    if (typeof extractComments === \"boolean\" && extractComments) {\r\n      condition.extract = \"some\";\r\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\r\n      condition.extract = extractComments;\r\n    } else if (typeof extractComments === \"function\") {\r\n      condition.extract = extractComments;\r\n    } else if (extractComments && isObject(extractComments)) {\r\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\r\n    } else {\r\n      // No extract\r\n      // Preserve using \"commentsOpts\" or \"some\"\r\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\r\n      condition.extract = false;\r\n    } // Ensure that both conditions are functions\r\n\r\n\r\n    [\"preserve\", \"extract\"].forEach(key => {\r\n      /** @type {undefined | string} */\r\n      let regexStr;\r\n      /** @type {undefined | RegExp} */\r\n\r\n      let regex;\r\n\r\n      switch (typeof condition[key]) {\r\n        case \"boolean\":\r\n          condition[key] = condition[key] ? () => true : () => false;\r\n          break;\r\n\r\n        case \"function\":\r\n          break;\r\n\r\n        case \"string\":\r\n          if (condition[key] === \"all\") {\r\n            condition[key] = () => true;\r\n\r\n            break;\r\n          }\r\n\r\n          if (condition[key] === \"some\") {\r\n            condition[key] =\r\n            /** @type {ExtractCommentsFunction} */\r\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\r\n\r\n            break;\r\n          }\r\n\r\n          regexStr =\r\n          /** @type {string} */\r\n          condition[key];\r\n\r\n          condition[key] =\r\n          /** @type {ExtractCommentsFunction} */\r\n          (astNode, comment) => new RegExp(\r\n          /** @type {string} */\r\n          regexStr).test(comment.value);\r\n\r\n          break;\r\n\r\n        default:\r\n          regex =\r\n          /** @type {RegExp} */\r\n          condition[key];\r\n\r\n          condition[key] =\r\n          /** @type {ExtractCommentsFunction} */\r\n          (astNode, comment) =>\r\n          /** @type {RegExp} */\r\n          regex.test(comment.value);\r\n\r\n      }\r\n    }); // Redefine the comments function to extract and preserve\r\n    // comments according to the two conditions\r\n\r\n    return (astNode, comment) => {\r\n      if (\r\n      /** @type {{ extract: ExtractCommentsFunction }} */\r\n      condition.extract(astNode, comment)) {\r\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\r\n\r\n        if (!extractedComments.includes(commentText)) {\r\n          extractedComments.push(commentText);\r\n        }\r\n      }\r\n\r\n      return (\r\n        /** @type {{ preserve: ExtractCommentsFunction }} */\r\n        condition.preserve(astNode, comment)\r\n      );\r\n    };\r\n  };\r\n  /**\r\n   * @param {PredefinedOptions & TerserOptions} [terserOptions={}]\r\n   * @returns {TerserOptions & { sourceMap: undefined } & { compress: TerserCompressOptions } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })}\r\n   */\r\n\r\n\r\n  const buildTerserOptions = (terserOptions = {}) => {\r\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\r\n    return { ...terserOptions,\r\n      compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress ? {} : false : { ...terserOptions.compress\r\n      },\r\n      // ecma: terserOptions.ecma,\r\n      // ie8: terserOptions.ie8,\r\n      // keep_classnames: terserOptions.keep_classnames,\r\n      // keep_fnames: terserOptions.keep_fnames,\r\n      mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : { ...terserOptions.mangle\r\n      },\r\n      // module: terserOptions.module,\r\n      // nameCache: { ...terserOptions.toplevel },\r\n      // the `output` option is deprecated\r\n      ...(terserOptions.format ? {\r\n        format: {\r\n          beautify: false,\r\n          ...terserOptions.format\r\n        }\r\n      } : {\r\n        output: {\r\n          beautify: false,\r\n          ...terserOptions.output\r\n        }\r\n      }),\r\n      parse: { ...terserOptions.parse\r\n      },\r\n      // safari10: terserOptions.safari10,\r\n      // Ignoring sourceMap from options\r\n      // eslint-disable-next-line no-undefined\r\n      sourceMap: undefined // toplevel: terserOptions.toplevel\r\n\r\n    };\r\n  }; // eslint-disable-next-line global-require\r\n\r\n\r\n  const {\r\n    minify\r\n  } = require(\"terser\"); // Copy `terser` options\r\n\r\n\r\n  const terserOptions = buildTerserOptions(minimizerOptions); // Let terser generate a SourceMap\r\n\r\n  if (sourceMap) {\r\n    // @ts-ignore\r\n    terserOptions.sourceMap = {\r\n      asObject: true\r\n    };\r\n  }\r\n  /** @type {ExtractedComments} */\r\n\r\n\r\n  const extractedComments = [];\r\n\r\n  if (terserOptions.output) {\r\n    terserOptions.output.comments = buildComments(terserOptions, extractedComments);\r\n  } else if (terserOptions.format) {\r\n    terserOptions.format.comments = buildComments(terserOptions, extractedComments);\r\n  }\r\n\r\n  if (terserOptions.compress) {\r\n    // More optimizations\r\n    if (typeof terserOptions.compress.ecma === \"undefined\") {\r\n      terserOptions.compress.ecma = terserOptions.ecma;\r\n    } // https://github.com/webpack/webpack/issues/16135\r\n\r\n\r\n    if (terserOptions.ecma === 5 && typeof terserOptions.compress.arrows === \"undefined\") {\r\n      terserOptions.compress.arrows = false;\r\n    }\r\n  }\r\n\r\n  const [[filename, code]] = Object.entries(input);\r\n  const result = await minify({\r\n    [filename]: code\r\n  }, terserOptions);\r\n  return {\r\n    code:\r\n    /** @type {string} **/\r\n    result.code,\r\n    // @ts-ignore\r\n    // eslint-disable-next-line no-undefined\r\n    map: result.map ?\r\n    /** @type {SourceMapInput} **/\r\n    result.map : undefined,\r\n    extractedComments\r\n  };\r\n}\r\n/**\r\n * @returns {string | undefined}\r\n */\r\n\r\n\r\nterserMinify.getMinimizerVersion = () => {\r\n  let packageJson;\r\n\r\n  try {\r\n    // eslint-disable-next-line global-require\r\n    packageJson = require(\"terser/package.json\");\r\n  } catch (error) {// Ignore\r\n  }\r\n\r\n  return packageJson && packageJson.version;\r\n};\r\n/* istanbul ignore next */\r\n\r\n/**\r\n * @param {Input} input\r\n * @param {SourceMapInput | undefined} sourceMap\r\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\r\n * @param {ExtractCommentsOptions | undefined} extractComments\r\n * @return {Promise<MinimizedResult>}\r\n */\r\n\r\n\r\nasync function uglifyJsMinify(input, sourceMap, minimizerOptions, extractComments) {\r\n  /**\r\n   * @param {any} value\r\n   * @returns {boolean}\r\n   */\r\n  const isObject = value => {\r\n    const type = typeof value;\r\n    return value != null && (type === \"object\" || type === \"function\");\r\n  };\r\n  /**\r\n   * @param {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}} uglifyJsOptions\r\n   * @param {ExtractedComments} extractedComments\r\n   * @returns {ExtractCommentsFunction}\r\n   */\r\n\r\n\r\n  const buildComments = (uglifyJsOptions, extractedComments) => {\r\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\r\n    const condition = {};\r\n    const {\r\n      comments\r\n    } = uglifyJsOptions.output;\r\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\r\n\r\n    if (typeof extractComments === \"boolean\" && extractComments) {\r\n      condition.extract = \"some\";\r\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\r\n      condition.extract = extractComments;\r\n    } else if (typeof extractComments === \"function\") {\r\n      condition.extract = extractComments;\r\n    } else if (extractComments && isObject(extractComments)) {\r\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\r\n    } else {\r\n      // No extract\r\n      // Preserve using \"commentsOpts\" or \"some\"\r\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\r\n      condition.extract = false;\r\n    } // Ensure that both conditions are functions\r\n\r\n\r\n    [\"preserve\", \"extract\"].forEach(key => {\r\n      /** @type {undefined | string} */\r\n      let regexStr;\r\n      /** @type {undefined | RegExp} */\r\n\r\n      let regex;\r\n\r\n      switch (typeof condition[key]) {\r\n        case \"boolean\":\r\n          condition[key] = condition[key] ? () => true : () => false;\r\n          break;\r\n\r\n        case \"function\":\r\n          break;\r\n\r\n        case \"string\":\r\n          if (condition[key] === \"all\") {\r\n            condition[key] = () => true;\r\n\r\n            break;\r\n          }\r\n\r\n          if (condition[key] === \"some\") {\r\n            condition[key] =\r\n            /** @type {ExtractCommentsFunction} */\r\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\r\n\r\n            break;\r\n          }\r\n\r\n          regexStr =\r\n          /** @type {string} */\r\n          condition[key];\r\n\r\n          condition[key] =\r\n          /** @type {ExtractCommentsFunction} */\r\n          (astNode, comment) => new RegExp(\r\n          /** @type {string} */\r\n          regexStr).test(comment.value);\r\n\r\n          break;\r\n\r\n        default:\r\n          regex =\r\n          /** @type {RegExp} */\r\n          condition[key];\r\n\r\n          condition[key] =\r\n          /** @type {ExtractCommentsFunction} */\r\n          (astNode, comment) =>\r\n          /** @type {RegExp} */\r\n          regex.test(comment.value);\r\n\r\n      }\r\n    }); // Redefine the comments function to extract and preserve\r\n    // comments according to the two conditions\r\n\r\n    return (astNode, comment) => {\r\n      if (\r\n      /** @type {{ extract: ExtractCommentsFunction }} */\r\n      condition.extract(astNode, comment)) {\r\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\r\n\r\n        if (!extractedComments.includes(commentText)) {\r\n          extractedComments.push(commentText);\r\n        }\r\n      }\r\n\r\n      return (\r\n        /** @type {{ preserve: ExtractCommentsFunction }} */\r\n        condition.preserve(astNode, comment)\r\n      );\r\n    };\r\n  };\r\n  /**\r\n   * @param {PredefinedOptions & import(\"uglify-js\").MinifyOptions} [uglifyJsOptions={}]\r\n   * @returns {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}}\r\n   */\r\n\r\n\r\n  const buildUglifyJsOptions = (uglifyJsOptions = {}) => {\r\n    // eslint-disable-next-line no-param-reassign\r\n    delete minimizerOptions.ecma; // eslint-disable-next-line no-param-reassign\r\n\r\n    delete minimizerOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\r\n\r\n    return { ...uglifyJsOptions,\r\n      // warnings: uglifyJsOptions.warnings,\r\n      parse: { ...uglifyJsOptions.parse\r\n      },\r\n      compress: typeof uglifyJsOptions.compress === \"boolean\" ? uglifyJsOptions.compress : { ...uglifyJsOptions.compress\r\n      },\r\n      mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === \"boolean\" ? uglifyJsOptions.mangle : { ...uglifyJsOptions.mangle\r\n      },\r\n      output: {\r\n        beautify: false,\r\n        ...uglifyJsOptions.output\r\n      },\r\n      // Ignoring sourceMap from options\r\n      // eslint-disable-next-line no-undefined\r\n      sourceMap: undefined // toplevel: uglifyJsOptions.toplevel\r\n      // nameCache: { ...uglifyJsOptions.toplevel },\r\n      // ie8: uglifyJsOptions.ie8,\r\n      // keep_fnames: uglifyJsOptions.keep_fnames,\r\n\r\n    };\r\n  }; // eslint-disable-next-line global-require, import/no-extraneous-dependencies\r\n\r\n\r\n  const {\r\n    minify\r\n  } = require(\"uglify-js\"); // Copy `uglify-js` options\r\n\r\n\r\n  const uglifyJsOptions = buildUglifyJsOptions(minimizerOptions); // Let terser generate a SourceMap\r\n\r\n  if (sourceMap) {\r\n    // @ts-ignore\r\n    uglifyJsOptions.sourceMap = true;\r\n  }\r\n  /** @type {ExtractedComments} */\r\n\r\n\r\n  const extractedComments = []; // @ts-ignore\r\n\r\n  uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);\r\n  const [[filename, code]] = Object.entries(input);\r\n  const result = await minify({\r\n    [filename]: code\r\n  }, uglifyJsOptions);\r\n  return {\r\n    code: result.code,\r\n    // eslint-disable-next-line no-undefined\r\n    map: result.map ? JSON.parse(result.map) : undefined,\r\n    errors: result.error ? [result.error] : [],\r\n    warnings: result.warnings || [],\r\n    extractedComments\r\n  };\r\n}\r\n/**\r\n * @returns {string | undefined}\r\n */\r\n\r\n\r\nuglifyJsMinify.getMinimizerVersion = () => {\r\n  let packageJson;\r\n\r\n  try {\r\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\r\n    packageJson = require(\"uglify-js/package.json\");\r\n  } catch (error) {// Ignore\r\n  }\r\n\r\n  return packageJson && packageJson.version;\r\n};\r\n/* istanbul ignore next */\r\n\r\n/**\r\n * @param {Input} input\r\n * @param {SourceMapInput | undefined} sourceMap\r\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\r\n * @return {Promise<MinimizedResult>}\r\n */\r\n\r\n\r\nasync function swcMinify(input, sourceMap, minimizerOptions) {\r\n  /**\r\n   * @param {PredefinedOptions & import(\"@swc/core\").JsMinifyOptions} [swcOptions={}]\r\n   * @returns {import(\"@swc/core\").JsMinifyOptions & { sourceMap: undefined } & { compress: import(\"@swc/core\").TerserCompressOptions }}\r\n   */\r\n  const buildSwcOptions = (swcOptions = {}) => {\r\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\r\n    return { ...swcOptions,\r\n      compress: typeof swcOptions.compress === \"boolean\" ? swcOptions.compress ? {} : false : { ...swcOptions.compress\r\n      },\r\n      mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === \"boolean\" ? swcOptions.mangle : { ...swcOptions.mangle\r\n      },\r\n      // ecma: swcOptions.ecma,\r\n      // keep_classnames: swcOptions.keep_classnames,\r\n      // keep_fnames: swcOptions.keep_fnames,\r\n      // module: swcOptions.module,\r\n      // safari10: swcOptions.safari10,\r\n      // toplevel: swcOptions.toplevel\r\n      // eslint-disable-next-line no-undefined\r\n      sourceMap: undefined\r\n    };\r\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\r\n\r\n\r\n  const swc = require(\"@swc/core\"); // Copy `swc` options\r\n\r\n\r\n  const swcOptions = buildSwcOptions(minimizerOptions); // Let `swc` generate a SourceMap\r\n\r\n  if (sourceMap) {\r\n    // @ts-ignore\r\n    swcOptions.sourceMap = true;\r\n  }\r\n\r\n  if (swcOptions.compress) {\r\n    // More optimizations\r\n    if (typeof swcOptions.compress.ecma === \"undefined\") {\r\n      swcOptions.compress.ecma = swcOptions.ecma;\r\n    } // https://github.com/webpack/webpack/issues/16135\r\n\r\n\r\n    if (swcOptions.ecma === 5 && typeof swcOptions.compress.arrows === \"undefined\") {\r\n      swcOptions.compress.arrows = false;\r\n    }\r\n  }\r\n\r\n  const [[filename, code]] = Object.entries(input);\r\n  const result = await swc.minify(code, swcOptions);\r\n  let map;\r\n\r\n  if (result.map) {\r\n    map = JSON.parse(result.map); // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`\r\n\r\n    map.sources = [filename];\r\n    delete map.sourcesContent;\r\n  }\r\n\r\n  return {\r\n    code: result.code,\r\n    map\r\n  };\r\n}\r\n/**\r\n * @returns {string | undefined}\r\n */\r\n\r\n\r\nswcMinify.getMinimizerVersion = () => {\r\n  let packageJson;\r\n\r\n  try {\r\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\r\n    packageJson = require(\"@swc/core/package.json\");\r\n  } catch (error) {// Ignore\r\n  }\r\n\r\n  return packageJson && packageJson.version;\r\n};\r\n/* istanbul ignore next */\r\n\r\n/**\r\n * @param {Input} input\r\n * @param {SourceMapInput | undefined} sourceMap\r\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\r\n * @return {Promise<MinimizedResult>}\r\n */\r\n\r\n\r\nasync function esbuildMinify(input, sourceMap, minimizerOptions) {\r\n  /**\r\n   * @param {PredefinedOptions & import(\"esbuild\").TransformOptions} [esbuildOptions={}]\r\n   * @returns {import(\"esbuild\").TransformOptions}\r\n   */\r\n  const buildEsbuildOptions = (esbuildOptions = {}) => {\r\n    // eslint-disable-next-line no-param-reassign\r\n    delete esbuildOptions.ecma;\r\n\r\n    if (esbuildOptions.module) {\r\n      // eslint-disable-next-line no-param-reassign\r\n      esbuildOptions.format = \"esm\";\r\n    } // eslint-disable-next-line no-param-reassign\r\n\r\n\r\n    delete esbuildOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\r\n\r\n    return {\r\n      minify: true,\r\n      legalComments: \"inline\",\r\n      ...esbuildOptions,\r\n      sourcemap: false\r\n    };\r\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\r\n\r\n\r\n  const esbuild = require(\"esbuild\"); // Copy `esbuild` options\r\n\r\n\r\n  const esbuildOptions = buildEsbuildOptions(minimizerOptions); // Let `esbuild` generate a SourceMap\r\n\r\n  if (sourceMap) {\r\n    esbuildOptions.sourcemap = true;\r\n    esbuildOptions.sourcesContent = false;\r\n  }\r\n\r\n  const [[filename, code]] = Object.entries(input);\r\n  esbuildOptions.sourcefile = filename;\r\n  const result = await esbuild.transform(code, esbuildOptions);\r\n  return {\r\n    code: result.code,\r\n    // eslint-disable-next-line no-undefined\r\n    map: result.map ? JSON.parse(result.map) : undefined,\r\n    warnings: result.warnings.length > 0 ? result.warnings.map(item => {\r\n      return {\r\n        name: \"Warning\",\r\n        source: item.location && item.location.file,\r\n        line: item.location && item.location.line,\r\n        column: item.location && item.location.column,\r\n        plugin: item.pluginName,\r\n        message: `${item.text}${item.detail ? `\\nDetails:\\n${item.detail}` : \"\"}${item.notes.length > 0 ? `\\n\\nNotes:\\n${item.notes.map(note => `${note.location ? `[${note.location.file}:${note.location.line}:${note.location.column}] ` : \"\"}${note.text}${note.location ? `\\nSuggestion: ${note.location.suggestion}` : \"\"}${note.location ? `\\nLine text:\\n${note.location.lineText}\\n` : \"\"}`).join(\"\\n\")}` : \"\"}`\r\n      };\r\n    }) : []\r\n  };\r\n}\r\n/**\r\n * @returns {string | undefined}\r\n */\r\n\r\n\r\nesbuildMinify.getMinimizerVersion = () => {\r\n  let packageJson;\r\n\r\n  try {\r\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\r\n    packageJson = require(\"esbuild/package.json\");\r\n  } catch (error) {// Ignore\r\n  }\r\n\r\n  return packageJson && packageJson.version;\r\n};\r\n\r\nmodule.exports = {\r\n  throttleAll,\r\n  terserMinify,\r\n  uglifyJsMinify,\r\n  swcMinify,\r\n  esbuildMinify\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}