{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\r\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\r\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\r\n * `buffer[0]`, and the highest-order bit is bit #7 of\r\n * `buffer[buffer.length - 1]`.\r\n */\n\n/*\r\n * Modules used\r\n */\n\"use strict\";\n\n/*\r\n * Exported bindings\r\n */\n\n/**\r\n * Extracts the given number of bits from the buffer at the indicated\r\n * index, returning a simple number as the result. If bits are requested\r\n * that aren't covered by the buffer, the `defaultBit` is used as their\r\n * value.\r\n *\r\n * The `bitLength` must be no more than 32. The `defaultBit` if not\r\n * specified is taken to be `0`.\r\n */\nexport function extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n  result >>>= startBit;\n  return result;\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\r\n * Injects the given bits into the given buffer at the given index. Any\r\n * bits in the value beyond the length to set are ignored.\r\n */\n\nexport function inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\r\n * Gets the sign bit of the given buffer.\r\n */\n\nexport function getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\r\n * Gets the zero-based bit number of the highest-order bit with the\r\n * given value in the given buffer.\r\n *\r\n * If the buffer consists entirely of the other bit value, then this returns\r\n * `-1`.\r\n */\n\nexport function highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n    result--;\n  }\n  return result;\n}","map":{"version":3,"names":["extract","buffer","bitIndex","bitLength","defaultBit","Error","undefined","defaultByte","result","lastBit","startByte","Math","floor","startBit","endByte","endBit","get","index","inject","value","lastByte","length","atByte","atBit","getSign","highOrder","bit","fullyWrongByte","byteToCheck","i"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/@webassemblyjs/leb128/esm/bits.js"],"sourcesContent":["// Copyright 2012 The Obvious Corporation.\r\n\r\n/*\r\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\r\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\r\n * `buffer[0]`, and the highest-order bit is bit #7 of\r\n * `buffer[buffer.length - 1]`.\r\n */\r\n\r\n/*\r\n * Modules used\r\n */\r\n\"use strict\";\r\n/*\r\n * Exported bindings\r\n */\r\n\r\n/**\r\n * Extracts the given number of bits from the buffer at the indicated\r\n * index, returning a simple number as the result. If bits are requested\r\n * that aren't covered by the buffer, the `defaultBit` is used as their\r\n * value.\r\n *\r\n * The `bitLength` must be no more than 32. The `defaultBit` if not\r\n * specified is taken to be `0`.\r\n */\r\n\r\nexport function extract(buffer, bitIndex, bitLength, defaultBit) {\r\n  if (bitLength < 0 || bitLength > 32) {\r\n    throw new Error(\"Bad value for bitLength.\");\r\n  }\r\n\r\n  if (defaultBit === undefined) {\r\n    defaultBit = 0;\r\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\r\n    throw new Error(\"Bad value for defaultBit.\");\r\n  }\r\n\r\n  var defaultByte = defaultBit * 0xff;\r\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\r\n  // if endBit !== 0, then endByte is inclusive.\r\n\r\n  var lastBit = bitIndex + bitLength;\r\n  var startByte = Math.floor(bitIndex / 8);\r\n  var startBit = bitIndex % 8;\r\n  var endByte = Math.floor(lastBit / 8);\r\n  var endBit = lastBit % 8;\r\n\r\n  if (endBit !== 0) {\r\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\r\n    // the endBit.\r\n    result = get(endByte) & (1 << endBit) - 1;\r\n  }\r\n\r\n  while (endByte > startByte) {\r\n    endByte--;\r\n    result = result << 8 | get(endByte);\r\n  }\r\n\r\n  result >>>= startBit;\r\n  return result;\r\n\r\n  function get(index) {\r\n    var result = buffer[index];\r\n    return result === undefined ? defaultByte : result;\r\n  }\r\n}\r\n/**\r\n * Injects the given bits into the given buffer at the given index. Any\r\n * bits in the value beyond the length to set are ignored.\r\n */\r\n\r\nexport function inject(buffer, bitIndex, bitLength, value) {\r\n  if (bitLength < 0 || bitLength > 32) {\r\n    throw new Error(\"Bad value for bitLength.\");\r\n  }\r\n\r\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\r\n\r\n  if (bitIndex < 0 || lastByte >= buffer.length) {\r\n    throw new Error(\"Index out of range.\");\r\n  } // Just keeping it simple, until / unless profiling shows that this\r\n  // is a problem.\r\n\r\n\r\n  var atByte = Math.floor(bitIndex / 8);\r\n  var atBit = bitIndex % 8;\r\n\r\n  while (bitLength > 0) {\r\n    if (value & 1) {\r\n      buffer[atByte] |= 1 << atBit;\r\n    } else {\r\n      buffer[atByte] &= ~(1 << atBit);\r\n    }\r\n\r\n    value >>= 1;\r\n    bitLength--;\r\n    atBit = (atBit + 1) % 8;\r\n\r\n    if (atBit === 0) {\r\n      atByte++;\r\n    }\r\n  }\r\n}\r\n/**\r\n * Gets the sign bit of the given buffer.\r\n */\r\n\r\nexport function getSign(buffer) {\r\n  return buffer[buffer.length - 1] >>> 7;\r\n}\r\n/**\r\n * Gets the zero-based bit number of the highest-order bit with the\r\n * given value in the given buffer.\r\n *\r\n * If the buffer consists entirely of the other bit value, then this returns\r\n * `-1`.\r\n */\r\n\r\nexport function highOrder(bit, buffer) {\r\n  var length = buffer.length;\r\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\r\n\r\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\r\n    length--;\r\n  }\r\n\r\n  if (length === 0) {\r\n    // Degenerate case. The buffer consists entirely of ~bit.\r\n    return -1;\r\n  }\r\n\r\n  var byteToCheck = buffer[length - 1];\r\n  var result = length * 8 - 1;\r\n\r\n  for (var i = 7; i > 0; i--) {\r\n    if ((byteToCheck >> i & 1) === bit) {\r\n      break;\r\n    }\r\n\r\n    result--;\r\n  }\r\n\r\n  return result;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}