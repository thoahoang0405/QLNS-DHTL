{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst {\n  AsyncSeriesBailHook,\n  AsyncSeriesHook,\n  SyncHook\n} = require(\"tapable\");\nconst createInnerContext = require(\"./createInnerContext\");\nconst {\n  parseIdentifier\n} = require(\"./util/identifier\");\nconst {\n  normalize,\n  cachedJoin: join,\n  getType,\n  PathType\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./ResolverFactory\").ResolveOptions} ResolveOptions */\n\n/**\r\n * @typedef {Object} FileSystemStats\r\n * @property {function(): boolean} isDirectory\r\n * @property {function(): boolean} isFile\r\n */\n\n/**\r\n * @typedef {Object} FileSystemDirent\r\n * @property {Buffer | string} name\r\n * @property {function(): boolean} isDirectory\r\n * @property {function(): boolean} isFile\r\n */\n\n/**\r\n * @typedef {Object} PossibleFileSystemError\r\n * @property {string=} code\r\n * @property {number=} errno\r\n * @property {string=} path\r\n * @property {string=} syscall\r\n */\n\n/**\r\n * @template T\r\n * @callback FileSystemCallback\r\n * @param {PossibleFileSystemError & Error | null | undefined} err\r\n * @param {T=} result\r\n */\n\n/**\r\n * @typedef {Object} FileSystem\r\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readFile\r\n * @property {(function(string, FileSystemCallback<(Buffer | string)[] | FileSystemDirent[]>): void) & function(string, object, FileSystemCallback<(Buffer | string)[] | FileSystemDirent[]>): void} readdir\r\n * @property {((function(string, FileSystemCallback<object>): void) & function(string, object, FileSystemCallback<object>): void)=} readJson\r\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readlink\r\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void=} lstat\r\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} stat\r\n */\n\n/**\r\n * @typedef {Object} SyncFileSystem\r\n * @property {function(string, object=): Buffer | string} readFileSync\r\n * @property {function(string, object=): (Buffer | string)[] | FileSystemDirent[]} readdirSync\r\n * @property {(function(string, object=): object)=} readJsonSync\r\n * @property {function(string, object=): Buffer | string} readlinkSync\r\n * @property {function(string, object=): FileSystemStats=} lstatSync\r\n * @property {function(string, object=): FileSystemStats} statSync\r\n */\n\n/**\r\n * @typedef {Object} ParsedIdentifier\r\n * @property {string} request\r\n * @property {string} query\r\n * @property {string} fragment\r\n * @property {boolean} directory\r\n * @property {boolean} module\r\n * @property {boolean} file\r\n * @property {boolean} internal\r\n */\n\n/**\r\n * @typedef {Object} BaseResolveRequest\r\n * @property {string | false} path\r\n * @property {string=} descriptionFilePath\r\n * @property {string=} descriptionFileRoot\r\n * @property {object=} descriptionFileData\r\n * @property {string=} relativePath\r\n * @property {boolean=} ignoreSymlinks\r\n * @property {boolean=} fullySpecified\r\n */\n\n/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */\n\n/**\r\n * String with special formatting\r\n * @typedef {string} StackEntry\r\n */\n\n/** @template T @typedef {{ add: (T) => void }} WriteOnlySet */\n\n/**\r\n * Resolve context\r\n * @typedef {Object} ResolveContext\r\n * @property {WriteOnlySet<string>=} contextDependencies\r\n * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system\r\n * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system\r\n * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\r\n * @property {(function(string): void)=} log log function\r\n * @property {(function (ResolveRequest): void)=} yield yield result, if provided plugins can return several results\r\n */\n\n/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */\n\n/**\r\n * @param {string} str input string\r\n * @returns {string} in camel case\r\n */\nfunction toCamelCase(str) {\n  return str.replace(/-([a-z])/g, str => str.substr(1).toUpperCase());\n}\nclass Resolver {\n  /**\r\n   * @param {ResolveStepHook} hook hook\r\n   * @param {ResolveRequest} request request\r\n   * @returns {StackEntry} stack entry\r\n   */\n  static createStackEntry(hook, request) {\n    return hook.name + \": (\" + request.path + \") \" + (request.request || \"\") + (request.query || \"\") + (request.fragment || \"\") + (request.directory ? \" directory\" : \"\") + (request.module ? \" module\" : \"\");\n  }\n\n  /**\r\n   * @param {FileSystem} fileSystem a filesystem\r\n   * @param {ResolveOptions} options options\r\n   */\n  constructor(fileSystem, options) {\n    this.fileSystem = fileSystem;\n    this.options = options;\n    this.hooks = {\n      /** @type {SyncHook<[ResolveStepHook, ResolveRequest], void>} */\n      resolveStep: new SyncHook([\"hook\", \"request\"], \"resolveStep\"),\n      /** @type {SyncHook<[ResolveRequest, Error]>} */\n      noResolve: new SyncHook([\"request\", \"error\"], \"noResolve\"),\n      /** @type {ResolveStepHook} */\n      resolve: new AsyncSeriesBailHook([\"request\", \"resolveContext\"], \"resolve\"),\n      /** @type {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} */\n      result: new AsyncSeriesHook([\"result\", \"resolveContext\"], \"result\")\n    };\n  }\n\n  /**\r\n   * @param {string | ResolveStepHook} name hook name or hook itself\r\n   * @returns {ResolveStepHook} the hook\r\n   */\n  ensureHook(name) {\n    if (typeof name !== \"string\") {\n      return name;\n    }\n    name = toCamelCase(name);\n    if (/^before/.test(name)) {\n      return (/** @type {ResolveStepHook} */this.ensureHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n          stage: -10\n        })\n      );\n    }\n    if (/^after/.test(name)) {\n      return (/** @type {ResolveStepHook} */this.ensureHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n          stage: 10\n        })\n      );\n    }\n    const hook = this.hooks[name];\n    if (!hook) {\n      return this.hooks[name] = new AsyncSeriesBailHook([\"request\", \"resolveContext\"], name);\n    }\n    return hook;\n  }\n\n  /**\r\n   * @param {string | ResolveStepHook} name hook name or hook itself\r\n   * @returns {ResolveStepHook} the hook\r\n   */\n  getHook(name) {\n    if (typeof name !== \"string\") {\n      return name;\n    }\n    name = toCamelCase(name);\n    if (/^before/.test(name)) {\n      return (/** @type {ResolveStepHook} */this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n          stage: -10\n        })\n      );\n    }\n    if (/^after/.test(name)) {\n      return (/** @type {ResolveStepHook} */this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n          stage: 10\n        })\n      );\n    }\n    const hook = this.hooks[name];\n    if (!hook) {\n      throw new Error(`Hook ${name} doesn't exist`);\n    }\n    return hook;\n  }\n\n  /**\r\n   * @param {object} context context information object\r\n   * @param {string} path context path\r\n   * @param {string} request request string\r\n   * @returns {string | false} result\r\n   */\n  resolveSync(context, path, request) {\n    /** @type {Error | null | undefined} */\n    let err = undefined;\n    /** @type {string | false | undefined} */\n    let result = undefined;\n    let sync = false;\n    this.resolve(context, path, request, {}, (e, r) => {\n      err = e;\n      result = r;\n      sync = true;\n    });\n    if (!sync) {\n      throw new Error(\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\");\n    }\n    if (err) throw err;\n    if (result === undefined) throw new Error(\"No result\");\n    return result;\n  }\n\n  /**\r\n   * @param {object} context context information object\r\n   * @param {string} path context path\r\n   * @param {string} request request string\r\n   * @param {ResolveContext} resolveContext resolve context\r\n   * @param {function(Error | null, (string|false)=, ResolveRequest=): void} callback callback function\r\n   * @returns {void}\r\n   */\n  resolve(context, path, request, resolveContext, callback) {\n    if (!context || typeof context !== \"object\") return callback(new Error(\"context argument is not an object\"));\n    if (typeof path !== \"string\") return callback(new Error(\"path argument is not a string\"));\n    if (typeof request !== \"string\") return callback(new Error(\"request argument is not a string\"));\n    if (!resolveContext) return callback(new Error(\"resolveContext argument is not set\"));\n    const obj = {\n      context: context,\n      path: path,\n      request: request\n    };\n    let yield_;\n    let yieldCalled = false;\n    let finishYield;\n    if (typeof resolveContext.yield === \"function\") {\n      const old = resolveContext.yield;\n      yield_ = obj => {\n        old(obj);\n        yieldCalled = true;\n      };\n      finishYield = result => {\n        if (result) yield_(result);\n        callback(null);\n      };\n    }\n    const message = `resolve '${request}' in '${path}'`;\n    const finishResolved = result => {\n      return callback(null, result.path === false ? false : `${result.path.replace(/#/g, \"\\0#\")}${result.query ? result.query.replace(/#/g, \"\\0#\") : \"\"}${result.fragment || \"\"}`, result);\n    };\n    const finishWithoutResolve = log => {\n      /**\r\n       * @type {Error & {details?: string}}\r\n       */\n      const error = new Error(\"Can't \" + message);\n      error.details = log.join(\"\\n\");\n      this.hooks.noResolve.call(obj, error);\n      return callback(error);\n    };\n    if (resolveContext.log) {\n      // We need log anyway to capture it in case of an error\n      const parentLog = resolveContext.log;\n      const log = [];\n      return this.doResolve(this.hooks.resolve, obj, message, {\n        log: msg => {\n          parentLog(msg);\n          log.push(msg);\n        },\n        yield: yield_,\n        fileDependencies: resolveContext.fileDependencies,\n        contextDependencies: resolveContext.contextDependencies,\n        missingDependencies: resolveContext.missingDependencies,\n        stack: resolveContext.stack\n      }, (err, result) => {\n        if (err) return callback(err);\n        if (yieldCalled || result && yield_) return finishYield(result);\n        if (result) return finishResolved(result);\n        return finishWithoutResolve(log);\n      });\n    } else {\n      // Try to resolve assuming there is no error\n      // We don't log stuff in this case\n      return this.doResolve(this.hooks.resolve, obj, message, {\n        log: undefined,\n        yield: yield_,\n        fileDependencies: resolveContext.fileDependencies,\n        contextDependencies: resolveContext.contextDependencies,\n        missingDependencies: resolveContext.missingDependencies,\n        stack: resolveContext.stack\n      }, (err, result) => {\n        if (err) return callback(err);\n        if (yieldCalled || result && yield_) return finishYield(result);\n        if (result) return finishResolved(result);\n\n        // log is missing for the error details\n        // so we redo the resolving for the log info\n        // this is more expensive to the success case\n        // is assumed by default\n\n        const log = [];\n        return this.doResolve(this.hooks.resolve, obj, message, {\n          log: msg => log.push(msg),\n          yield: yield_,\n          stack: resolveContext.stack\n        }, (err, result) => {\n          if (err) return callback(err);\n\n          // In a case that there is a race condition and yield will be called\n          if (yieldCalled || result && yield_) return finishYield(result);\n          return finishWithoutResolve(log);\n        });\n      });\n    }\n  }\n  doResolve(hook, request, message, resolveContext, callback) {\n    const stackEntry = Resolver.createStackEntry(hook, request);\n    let newStack;\n    if (resolveContext.stack) {\n      newStack = new Set(resolveContext.stack);\n      if (resolveContext.stack.has(stackEntry)) {\n        /**\r\n         * Prevent recursion\r\n         * @type {Error & {recursion?: boolean}}\r\n         */\n        const recursionError = new Error(\"Recursion in resolving\\nStack:\\n  \" + Array.from(newStack).join(\"\\n  \"));\n        recursionError.recursion = true;\n        if (resolveContext.log) resolveContext.log(\"abort resolving because of recursion\");\n        return callback(recursionError);\n      }\n      newStack.add(stackEntry);\n    } else {\n      newStack = new Set([stackEntry]);\n    }\n    this.hooks.resolveStep.call(hook, request);\n    if (hook.isUsed()) {\n      const innerContext = createInnerContext({\n        log: resolveContext.log,\n        yield: resolveContext.yield,\n        fileDependencies: resolveContext.fileDependencies,\n        contextDependencies: resolveContext.contextDependencies,\n        missingDependencies: resolveContext.missingDependencies,\n        stack: newStack\n      }, message);\n      return hook.callAsync(request, innerContext, (err, result) => {\n        if (err) return callback(err);\n        if (result) return callback(null, result);\n        callback();\n      });\n    } else {\n      callback();\n    }\n  }\n\n  /**\r\n   * @param {string} identifier identifier\r\n   * @returns {ParsedIdentifier} parsed identifier\r\n   */\n  parse(identifier) {\n    const part = {\n      request: \"\",\n      query: \"\",\n      fragment: \"\",\n      module: false,\n      directory: false,\n      file: false,\n      internal: false\n    };\n    const parsedIdentifier = parseIdentifier(identifier);\n    if (!parsedIdentifier) return part;\n    [part.request, part.query, part.fragment] = parsedIdentifier;\n    if (part.request.length > 0) {\n      part.internal = this.isPrivate(identifier);\n      part.module = this.isModule(part.request);\n      part.directory = this.isDirectory(part.request);\n      if (part.directory) {\n        part.request = part.request.substr(0, part.request.length - 1);\n      }\n    }\n    return part;\n  }\n  isModule(path) {\n    return getType(path) === PathType.Normal;\n  }\n  isPrivate(path) {\n    return getType(path) === PathType.Internal;\n  }\n\n  /**\r\n   * @param {string} path a path\r\n   * @returns {boolean} true, if the path is a directory path\r\n   */\n  isDirectory(path) {\n    return path.endsWith(\"/\");\n  }\n  join(path, request) {\n    return join(path, request);\n  }\n  normalize(path) {\n    return normalize(path);\n  }\n}\nmodule.exports = Resolver;","map":{"version":3,"names":["require","AsyncSeriesBailHook","AsyncSeriesHook","SyncHook","createInnerContext","parseIdentifier","normalize","cachedJoin","join","getType","PathType","toCamelCase","str","replace","substr","toUpperCase","Resolver","createStackEntry","hook","request","name","path","query","fragment","directory","module","constructor","fileSystem","options","hooks","resolveStep","noResolve","resolve","result","ensureHook","test","toLowerCase","withOptions","stage","getHook","Error","resolveSync","context","err","undefined","sync","e","r","resolveContext","callback","obj","yield_","yieldCalled","finishYield","yield","old","message","finishResolved","finishWithoutResolve","log","error","details","call","parentLog","doResolve","msg","push","fileDependencies","contextDependencies","missingDependencies","stack","stackEntry","newStack","Set","has","recursionError","Array","from","recursion","add","isUsed","innerContext","callAsync","parse","identifier","part","file","internal","parsedIdentifier","length","isPrivate","isModule","isDirectory","Normal","Internal","endsWith","exports"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/enhanced-resolve/lib/Resolver.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } = require(\"tapable\");\r\nconst createInnerContext = require(\"./createInnerContext\");\r\nconst { parseIdentifier } = require(\"./util/identifier\");\r\nconst {\r\n\tnormalize,\r\n\tcachedJoin: join,\r\n\tgetType,\r\n\tPathType\r\n} = require(\"./util/path\");\r\n\r\n/** @typedef {import(\"./ResolverFactory\").ResolveOptions} ResolveOptions */\r\n\r\n/**\r\n * @typedef {Object} FileSystemStats\r\n * @property {function(): boolean} isDirectory\r\n * @property {function(): boolean} isFile\r\n */\r\n\r\n/**\r\n * @typedef {Object} FileSystemDirent\r\n * @property {Buffer | string} name\r\n * @property {function(): boolean} isDirectory\r\n * @property {function(): boolean} isFile\r\n */\r\n\r\n/**\r\n * @typedef {Object} PossibleFileSystemError\r\n * @property {string=} code\r\n * @property {number=} errno\r\n * @property {string=} path\r\n * @property {string=} syscall\r\n */\r\n\r\n/**\r\n * @template T\r\n * @callback FileSystemCallback\r\n * @param {PossibleFileSystemError & Error | null | undefined} err\r\n * @param {T=} result\r\n */\r\n\r\n/**\r\n * @typedef {Object} FileSystem\r\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readFile\r\n * @property {(function(string, FileSystemCallback<(Buffer | string)[] | FileSystemDirent[]>): void) & function(string, object, FileSystemCallback<(Buffer | string)[] | FileSystemDirent[]>): void} readdir\r\n * @property {((function(string, FileSystemCallback<object>): void) & function(string, object, FileSystemCallback<object>): void)=} readJson\r\n * @property {(function(string, FileSystemCallback<Buffer | string>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} readlink\r\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void=} lstat\r\n * @property {(function(string, FileSystemCallback<FileSystemStats>): void) & function(string, object, FileSystemCallback<Buffer | string>): void} stat\r\n */\r\n\r\n/**\r\n * @typedef {Object} SyncFileSystem\r\n * @property {function(string, object=): Buffer | string} readFileSync\r\n * @property {function(string, object=): (Buffer | string)[] | FileSystemDirent[]} readdirSync\r\n * @property {(function(string, object=): object)=} readJsonSync\r\n * @property {function(string, object=): Buffer | string} readlinkSync\r\n * @property {function(string, object=): FileSystemStats=} lstatSync\r\n * @property {function(string, object=): FileSystemStats} statSync\r\n */\r\n\r\n/**\r\n * @typedef {Object} ParsedIdentifier\r\n * @property {string} request\r\n * @property {string} query\r\n * @property {string} fragment\r\n * @property {boolean} directory\r\n * @property {boolean} module\r\n * @property {boolean} file\r\n * @property {boolean} internal\r\n */\r\n\r\n/**\r\n * @typedef {Object} BaseResolveRequest\r\n * @property {string | false} path\r\n * @property {string=} descriptionFilePath\r\n * @property {string=} descriptionFileRoot\r\n * @property {object=} descriptionFileData\r\n * @property {string=} relativePath\r\n * @property {boolean=} ignoreSymlinks\r\n * @property {boolean=} fullySpecified\r\n */\r\n\r\n/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */\r\n\r\n/**\r\n * String with special formatting\r\n * @typedef {string} StackEntry\r\n */\r\n\r\n/** @template T @typedef {{ add: (T) => void }} WriteOnlySet */\r\n\r\n/**\r\n * Resolve context\r\n * @typedef {Object} ResolveContext\r\n * @property {WriteOnlySet<string>=} contextDependencies\r\n * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system\r\n * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system\r\n * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\r\n * @property {(function(string): void)=} log log function\r\n * @property {(function (ResolveRequest): void)=} yield yield result, if provided plugins can return several results\r\n */\r\n\r\n/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */\r\n\r\n/**\r\n * @param {string} str input string\r\n * @returns {string} in camel case\r\n */\r\nfunction toCamelCase(str) {\r\n\treturn str.replace(/-([a-z])/g, str => str.substr(1).toUpperCase());\r\n}\r\n\r\nclass Resolver {\r\n\t/**\r\n\t * @param {ResolveStepHook} hook hook\r\n\t * @param {ResolveRequest} request request\r\n\t * @returns {StackEntry} stack entry\r\n\t */\r\n\tstatic createStackEntry(hook, request) {\r\n\t\treturn (\r\n\t\t\thook.name +\r\n\t\t\t\": (\" +\r\n\t\t\trequest.path +\r\n\t\t\t\") \" +\r\n\t\t\t(request.request || \"\") +\r\n\t\t\t(request.query || \"\") +\r\n\t\t\t(request.fragment || \"\") +\r\n\t\t\t(request.directory ? \" directory\" : \"\") +\r\n\t\t\t(request.module ? \" module\" : \"\")\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {FileSystem} fileSystem a filesystem\r\n\t * @param {ResolveOptions} options options\r\n\t */\r\n\tconstructor(fileSystem, options) {\r\n\t\tthis.fileSystem = fileSystem;\r\n\t\tthis.options = options;\r\n\t\tthis.hooks = {\r\n\t\t\t/** @type {SyncHook<[ResolveStepHook, ResolveRequest], void>} */\r\n\t\t\tresolveStep: new SyncHook([\"hook\", \"request\"], \"resolveStep\"),\r\n\t\t\t/** @type {SyncHook<[ResolveRequest, Error]>} */\r\n\t\t\tnoResolve: new SyncHook([\"request\", \"error\"], \"noResolve\"),\r\n\t\t\t/** @type {ResolveStepHook} */\r\n\t\t\tresolve: new AsyncSeriesBailHook(\r\n\t\t\t\t[\"request\", \"resolveContext\"],\r\n\t\t\t\t\"resolve\"\r\n\t\t\t),\r\n\t\t\t/** @type {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} */\r\n\t\t\tresult: new AsyncSeriesHook([\"result\", \"resolveContext\"], \"result\")\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string | ResolveStepHook} name hook name or hook itself\r\n\t * @returns {ResolveStepHook} the hook\r\n\t */\r\n\tensureHook(name) {\r\n\t\tif (typeof name !== \"string\") {\r\n\t\t\treturn name;\r\n\t\t}\r\n\t\tname = toCamelCase(name);\r\n\t\tif (/^before/.test(name)) {\r\n\t\t\treturn /** @type {ResolveStepHook} */ (this.ensureHook(\r\n\t\t\t\tname[6].toLowerCase() + name.substr(7)\r\n\t\t\t).withOptions({\r\n\t\t\t\tstage: -10\r\n\t\t\t}));\r\n\t\t}\r\n\t\tif (/^after/.test(name)) {\r\n\t\t\treturn /** @type {ResolveStepHook} */ (this.ensureHook(\r\n\t\t\t\tname[5].toLowerCase() + name.substr(6)\r\n\t\t\t).withOptions({\r\n\t\t\t\tstage: 10\r\n\t\t\t}));\r\n\t\t}\r\n\t\tconst hook = this.hooks[name];\r\n\t\tif (!hook) {\r\n\t\t\treturn (this.hooks[name] = new AsyncSeriesBailHook(\r\n\t\t\t\t[\"request\", \"resolveContext\"],\r\n\t\t\t\tname\r\n\t\t\t));\r\n\t\t}\r\n\t\treturn hook;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string | ResolveStepHook} name hook name or hook itself\r\n\t * @returns {ResolveStepHook} the hook\r\n\t */\r\n\tgetHook(name) {\r\n\t\tif (typeof name !== \"string\") {\r\n\t\t\treturn name;\r\n\t\t}\r\n\t\tname = toCamelCase(name);\r\n\t\tif (/^before/.test(name)) {\r\n\t\t\treturn /** @type {ResolveStepHook} */ (this.getHook(\r\n\t\t\t\tname[6].toLowerCase() + name.substr(7)\r\n\t\t\t).withOptions({\r\n\t\t\t\tstage: -10\r\n\t\t\t}));\r\n\t\t}\r\n\t\tif (/^after/.test(name)) {\r\n\t\t\treturn /** @type {ResolveStepHook} */ (this.getHook(\r\n\t\t\t\tname[5].toLowerCase() + name.substr(6)\r\n\t\t\t).withOptions({\r\n\t\t\t\tstage: 10\r\n\t\t\t}));\r\n\t\t}\r\n\t\tconst hook = this.hooks[name];\r\n\t\tif (!hook) {\r\n\t\t\tthrow new Error(`Hook ${name} doesn't exist`);\r\n\t\t}\r\n\t\treturn hook;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {object} context context information object\r\n\t * @param {string} path context path\r\n\t * @param {string} request request string\r\n\t * @returns {string | false} result\r\n\t */\r\n\tresolveSync(context, path, request) {\r\n\t\t/** @type {Error | null | undefined} */\r\n\t\tlet err = undefined;\r\n\t\t/** @type {string | false | undefined} */\r\n\t\tlet result = undefined;\r\n\t\tlet sync = false;\r\n\t\tthis.resolve(context, path, request, {}, (e, r) => {\r\n\t\t\terr = e;\r\n\t\t\tresult = r;\r\n\t\t\tsync = true;\r\n\t\t});\r\n\t\tif (!sync) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\"\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (err) throw err;\r\n\t\tif (result === undefined) throw new Error(\"No result\");\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {object} context context information object\r\n\t * @param {string} path context path\r\n\t * @param {string} request request string\r\n\t * @param {ResolveContext} resolveContext resolve context\r\n\t * @param {function(Error | null, (string|false)=, ResolveRequest=): void} callback callback function\r\n\t * @returns {void}\r\n\t */\r\n\tresolve(context, path, request, resolveContext, callback) {\r\n\t\tif (!context || typeof context !== \"object\")\r\n\t\t\treturn callback(new Error(\"context argument is not an object\"));\r\n\t\tif (typeof path !== \"string\")\r\n\t\t\treturn callback(new Error(\"path argument is not a string\"));\r\n\t\tif (typeof request !== \"string\")\r\n\t\t\treturn callback(new Error(\"request argument is not a string\"));\r\n\t\tif (!resolveContext)\r\n\t\t\treturn callback(new Error(\"resolveContext argument is not set\"));\r\n\r\n\t\tconst obj = {\r\n\t\t\tcontext: context,\r\n\t\t\tpath: path,\r\n\t\t\trequest: request\r\n\t\t};\r\n\r\n\t\tlet yield_;\r\n\t\tlet yieldCalled = false;\r\n\t\tlet finishYield;\r\n\t\tif (typeof resolveContext.yield === \"function\") {\r\n\t\t\tconst old = resolveContext.yield;\r\n\t\t\tyield_ = obj => {\r\n\t\t\t\told(obj);\r\n\t\t\t\tyieldCalled = true;\r\n\t\t\t};\r\n\t\t\tfinishYield = result => {\r\n\t\t\t\tif (result) yield_(result);\r\n\t\t\t\tcallback(null);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tconst message = `resolve '${request}' in '${path}'`;\r\n\r\n\t\tconst finishResolved = result => {\r\n\t\t\treturn callback(\r\n\t\t\t\tnull,\r\n\t\t\t\tresult.path === false\r\n\t\t\t\t\t? false\r\n\t\t\t\t\t: `${result.path.replace(/#/g, \"\\0#\")}${\r\n\t\t\t\t\t\t\tresult.query ? result.query.replace(/#/g, \"\\0#\") : \"\"\r\n\t\t\t\t\t  }${result.fragment || \"\"}`,\r\n\t\t\t\tresult\r\n\t\t\t);\r\n\t\t};\r\n\r\n\t\tconst finishWithoutResolve = log => {\r\n\t\t\t/**\r\n\t\t\t * @type {Error & {details?: string}}\r\n\t\t\t */\r\n\t\t\tconst error = new Error(\"Can't \" + message);\r\n\t\t\terror.details = log.join(\"\\n\");\r\n\t\t\tthis.hooks.noResolve.call(obj, error);\r\n\t\t\treturn callback(error);\r\n\t\t};\r\n\r\n\t\tif (resolveContext.log) {\r\n\t\t\t// We need log anyway to capture it in case of an error\r\n\t\t\tconst parentLog = resolveContext.log;\r\n\t\t\tconst log = [];\r\n\t\t\treturn this.doResolve(\r\n\t\t\t\tthis.hooks.resolve,\r\n\t\t\t\tobj,\r\n\t\t\t\tmessage,\r\n\t\t\t\t{\r\n\t\t\t\t\tlog: msg => {\r\n\t\t\t\t\t\tparentLog(msg);\r\n\t\t\t\t\t\tlog.push(msg);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tyield: yield_,\r\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\r\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\r\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\r\n\t\t\t\t\tstack: resolveContext.stack\r\n\t\t\t\t},\r\n\t\t\t\t(err, result) => {\r\n\t\t\t\t\tif (err) return callback(err);\r\n\r\n\t\t\t\t\tif (yieldCalled || (result && yield_)) return finishYield(result);\r\n\t\t\t\t\tif (result) return finishResolved(result);\r\n\r\n\t\t\t\t\treturn finishWithoutResolve(log);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\t// Try to resolve assuming there is no error\r\n\t\t\t// We don't log stuff in this case\r\n\t\t\treturn this.doResolve(\r\n\t\t\t\tthis.hooks.resolve,\r\n\t\t\t\tobj,\r\n\t\t\t\tmessage,\r\n\t\t\t\t{\r\n\t\t\t\t\tlog: undefined,\r\n\t\t\t\t\tyield: yield_,\r\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\r\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\r\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\r\n\t\t\t\t\tstack: resolveContext.stack\r\n\t\t\t\t},\r\n\t\t\t\t(err, result) => {\r\n\t\t\t\t\tif (err) return callback(err);\r\n\r\n\t\t\t\t\tif (yieldCalled || (result && yield_)) return finishYield(result);\r\n\t\t\t\t\tif (result) return finishResolved(result);\r\n\r\n\t\t\t\t\t// log is missing for the error details\r\n\t\t\t\t\t// so we redo the resolving for the log info\r\n\t\t\t\t\t// this is more expensive to the success case\r\n\t\t\t\t\t// is assumed by default\r\n\r\n\t\t\t\t\tconst log = [];\r\n\r\n\t\t\t\t\treturn this.doResolve(\r\n\t\t\t\t\t\tthis.hooks.resolve,\r\n\t\t\t\t\t\tobj,\r\n\t\t\t\t\t\tmessage,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlog: msg => log.push(msg),\r\n\t\t\t\t\t\t\tyield: yield_,\r\n\t\t\t\t\t\t\tstack: resolveContext.stack\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t(err, result) => {\r\n\t\t\t\t\t\t\tif (err) return callback(err);\r\n\r\n\t\t\t\t\t\t\t// In a case that there is a race condition and yield will be called\r\n\t\t\t\t\t\t\tif (yieldCalled || (result && yield_)) return finishYield(result);\r\n\r\n\t\t\t\t\t\t\treturn finishWithoutResolve(log);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tdoResolve(hook, request, message, resolveContext, callback) {\r\n\t\tconst stackEntry = Resolver.createStackEntry(hook, request);\r\n\r\n\t\tlet newStack;\r\n\t\tif (resolveContext.stack) {\r\n\t\t\tnewStack = new Set(resolveContext.stack);\r\n\t\t\tif (resolveContext.stack.has(stackEntry)) {\r\n\t\t\t\t/**\r\n\t\t\t\t * Prevent recursion\r\n\t\t\t\t * @type {Error & {recursion?: boolean}}\r\n\t\t\t\t */\r\n\t\t\t\tconst recursionError = new Error(\r\n\t\t\t\t\t\"Recursion in resolving\\nStack:\\n  \" +\r\n\t\t\t\t\t\tArray.from(newStack).join(\"\\n  \")\r\n\t\t\t\t);\r\n\t\t\t\trecursionError.recursion = true;\r\n\t\t\t\tif (resolveContext.log)\r\n\t\t\t\t\tresolveContext.log(\"abort resolving because of recursion\");\r\n\t\t\t\treturn callback(recursionError);\r\n\t\t\t}\r\n\t\t\tnewStack.add(stackEntry);\r\n\t\t} else {\r\n\t\t\tnewStack = new Set([stackEntry]);\r\n\t\t}\r\n\t\tthis.hooks.resolveStep.call(hook, request);\r\n\r\n\t\tif (hook.isUsed()) {\r\n\t\t\tconst innerContext = createInnerContext(\r\n\t\t\t\t{\r\n\t\t\t\t\tlog: resolveContext.log,\r\n\t\t\t\t\tyield: resolveContext.yield,\r\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\r\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\r\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\r\n\t\t\t\t\tstack: newStack\r\n\t\t\t\t},\r\n\t\t\t\tmessage\r\n\t\t\t);\r\n\t\t\treturn hook.callAsync(request, innerContext, (err, result) => {\r\n\t\t\t\tif (err) return callback(err);\r\n\t\t\t\tif (result) return callback(null, result);\r\n\t\t\t\tcallback();\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tcallback();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} identifier identifier\r\n\t * @returns {ParsedIdentifier} parsed identifier\r\n\t */\r\n\tparse(identifier) {\r\n\t\tconst part = {\r\n\t\t\trequest: \"\",\r\n\t\t\tquery: \"\",\r\n\t\t\tfragment: \"\",\r\n\t\t\tmodule: false,\r\n\t\t\tdirectory: false,\r\n\t\t\tfile: false,\r\n\t\t\tinternal: false\r\n\t\t};\r\n\r\n\t\tconst parsedIdentifier = parseIdentifier(identifier);\r\n\r\n\t\tif (!parsedIdentifier) return part;\r\n\r\n\t\t[part.request, part.query, part.fragment] = parsedIdentifier;\r\n\r\n\t\tif (part.request.length > 0) {\r\n\t\t\tpart.internal = this.isPrivate(identifier);\r\n\t\t\tpart.module = this.isModule(part.request);\r\n\t\t\tpart.directory = this.isDirectory(part.request);\r\n\t\t\tif (part.directory) {\r\n\t\t\t\tpart.request = part.request.substr(0, part.request.length - 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn part;\r\n\t}\r\n\r\n\tisModule(path) {\r\n\t\treturn getType(path) === PathType.Normal;\r\n\t}\r\n\r\n\tisPrivate(path) {\r\n\t\treturn getType(path) === PathType.Internal;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} path a path\r\n\t * @returns {boolean} true, if the path is a directory path\r\n\t */\r\n\tisDirectory(path) {\r\n\t\treturn path.endsWith(\"/\");\r\n\t}\r\n\r\n\tjoin(path, request) {\r\n\t\treturn join(path, request);\r\n\t}\r\n\r\n\tnormalize(path) {\r\n\t\treturn normalize(path);\r\n\t}\r\n}\r\n\r\nmodule.exports = Resolver;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}