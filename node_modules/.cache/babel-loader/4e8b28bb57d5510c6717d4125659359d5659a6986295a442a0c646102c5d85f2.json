{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\nconst REPLACE_REGEX = /\\n(?=.|\\s)/g;\nclass PrefixSource extends Source {\n  constructor(prefix, source) {\n    super();\n    this._source = typeof source === \"string\" || Buffer.isBuffer(source) ? new RawSource(source, true) : source;\n    this._prefix = prefix;\n  }\n  getPrefix() {\n    return this._prefix;\n  }\n  original() {\n    return this._source;\n  }\n  source() {\n    const node = this._source.source();\n    const prefix = this._prefix;\n    return prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n  }\n\n  // TODO efficient buffer() implementation\n\n  map(options) {\n    return getMap(this, options);\n  }\n  sourceAndMap(options) {\n    return getSourceAndMap(this, options);\n  }\n  streamChunks(options, onChunk, onSource, onName) {\n    const prefix = this._prefix;\n    const prefixOffset = prefix.length;\n    const linesOnly = !!(options && options.columns === false);\n    const {\n      generatedLine,\n      generatedColumn,\n      source\n    } = streamChunks(this._source, options, (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n      if (generatedColumn !== 0) {\n        // In the middle of the line, we just adject the column\n        generatedColumn += prefixOffset;\n      } else if (chunk !== undefined) {\n        // At the start of the line, when we have source content\n        // add the prefix as generated mapping\n        // (in lines only mode we just add it to the original mapping\n        // for performance reasons)\n        if (linesOnly || sourceIndex < 0) {\n          chunk = prefix + chunk;\n        } else if (prefixOffset > 0) {\n          onChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);\n          generatedColumn += prefixOffset;\n        }\n      } else if (!linesOnly) {\n        // Without source content, we only need to adject the column info\n        // expect in lines only mode where prefix is added to original mapping\n        generatedColumn += prefixOffset;\n      }\n      onChunk(chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n    }, onSource, onName);\n    return {\n      generatedLine,\n      generatedColumn: generatedColumn === 0 ? 0 : prefixOffset + generatedColumn,\n      source: source !== undefined ? prefix + source.replace(REPLACE_REGEX, \"\\n\" + prefix) : undefined\n    };\n  }\n  updateHash(hash) {\n    hash.update(\"PrefixSource\");\n    this._source.updateHash(hash);\n    hash.update(this._prefix);\n  }\n}\nmodule.exports = PrefixSource;","map":{"version":3,"names":["Source","require","RawSource","streamChunks","getMap","getSourceAndMap","REPLACE_REGEX","PrefixSource","constructor","prefix","source","_source","Buffer","isBuffer","_prefix","getPrefix","original","node","replace","map","options","sourceAndMap","onChunk","onSource","onName","prefixOffset","length","linesOnly","columns","generatedLine","generatedColumn","chunk","sourceIndex","originalLine","originalColumn","nameIndex","undefined","updateHash","hash","update","module","exports"],"sources":["D:/dhtl/ptda/UI/QLNS-DHTL/node_modules/webpack-sources/lib/PrefixSource.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nconst Source = require(\"./Source\");\r\nconst RawSource = require(\"./RawSource\");\r\nconst streamChunks = require(\"./helpers/streamChunks\");\r\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\r\n\r\nconst REPLACE_REGEX = /\\n(?=.|\\s)/g;\r\n\r\nclass PrefixSource extends Source {\r\n\tconstructor(prefix, source) {\r\n\t\tsuper();\r\n\t\tthis._source =\r\n\t\t\ttypeof source === \"string\" || Buffer.isBuffer(source)\r\n\t\t\t\t? new RawSource(source, true)\r\n\t\t\t\t: source;\r\n\t\tthis._prefix = prefix;\r\n\t}\r\n\r\n\tgetPrefix() {\r\n\t\treturn this._prefix;\r\n\t}\r\n\r\n\toriginal() {\r\n\t\treturn this._source;\r\n\t}\r\n\r\n\tsource() {\r\n\t\tconst node = this._source.source();\r\n\t\tconst prefix = this._prefix;\r\n\t\treturn prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\r\n\t}\r\n\r\n\t// TODO efficient buffer() implementation\r\n\r\n\tmap(options) {\r\n\t\treturn getMap(this, options);\r\n\t}\r\n\r\n\tsourceAndMap(options) {\r\n\t\treturn getSourceAndMap(this, options);\r\n\t}\r\n\r\n\tstreamChunks(options, onChunk, onSource, onName) {\r\n\t\tconst prefix = this._prefix;\r\n\t\tconst prefixOffset = prefix.length;\r\n\t\tconst linesOnly = !!(options && options.columns === false);\r\n\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\r\n\t\t\tthis._source,\r\n\t\t\toptions,\r\n\t\t\t(\r\n\t\t\t\tchunk,\r\n\t\t\t\tgeneratedLine,\r\n\t\t\t\tgeneratedColumn,\r\n\t\t\t\tsourceIndex,\r\n\t\t\t\toriginalLine,\r\n\t\t\t\toriginalColumn,\r\n\t\t\t\tnameIndex\r\n\t\t\t) => {\r\n\t\t\t\tif (generatedColumn !== 0) {\r\n\t\t\t\t\t// In the middle of the line, we just adject the column\r\n\t\t\t\t\tgeneratedColumn += prefixOffset;\r\n\t\t\t\t} else if (chunk !== undefined) {\r\n\t\t\t\t\t// At the start of the line, when we have source content\r\n\t\t\t\t\t// add the prefix as generated mapping\r\n\t\t\t\t\t// (in lines only mode we just add it to the original mapping\r\n\t\t\t\t\t// for performance reasons)\r\n\t\t\t\t\tif (linesOnly || sourceIndex < 0) {\r\n\t\t\t\t\t\tchunk = prefix + chunk;\r\n\t\t\t\t\t} else if (prefixOffset > 0) {\r\n\t\t\t\t\t\tonChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);\r\n\t\t\t\t\t\tgeneratedColumn += prefixOffset;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (!linesOnly) {\r\n\t\t\t\t\t// Without source content, we only need to adject the column info\r\n\t\t\t\t\t// expect in lines only mode where prefix is added to original mapping\r\n\t\t\t\t\tgeneratedColumn += prefixOffset;\r\n\t\t\t\t}\r\n\t\t\t\tonChunk(\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tgeneratedLine,\r\n\t\t\t\t\tgeneratedColumn,\r\n\t\t\t\t\tsourceIndex,\r\n\t\t\t\t\toriginalLine,\r\n\t\t\t\t\toriginalColumn,\r\n\t\t\t\t\tnameIndex\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tonSource,\r\n\t\t\tonName\r\n\t\t);\r\n\t\treturn {\r\n\t\t\tgeneratedLine,\r\n\t\t\tgeneratedColumn:\r\n\t\t\t\tgeneratedColumn === 0 ? 0 : prefixOffset + generatedColumn,\r\n\t\t\tsource:\r\n\t\t\t\tsource !== undefined\r\n\t\t\t\t\t? prefix + source.replace(REPLACE_REGEX, \"\\n\" + prefix)\r\n\t\t\t\t\t: undefined\r\n\t\t};\r\n\t}\r\n\r\n\tupdateHash(hash) {\r\n\t\thash.update(\"PrefixSource\");\r\n\t\tthis._source.updateHash(hash);\r\n\t\thash.update(this._prefix);\r\n\t}\r\n}\r\n\r\nmodule.exports = PrefixSource;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}